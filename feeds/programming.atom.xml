<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Skydark's blog</title><link href="http://blog.skydark.info/" rel="alternate"></link><link href="http://blog.skydark.info/feeds/programming.atom.xml" rel="self"></link><id>http://blog.skydark.info/</id><updated>2013-05-29T00:00:00+08:00</updated><entry><title>备份 Google Reader 保存下来的网站历史存档</title><link href="http://blog.skydark.info/programming/2013/05/29/backup-gr-archives/" rel="alternate"></link><published>2013-05-29T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2013-05-29:programming/2013/05/29/backup-gr-archives/</id><summary type="html">&lt;p&gt;离 Google 宣布 Google Reader 要关闭的日子已经不远了。
在各种 Google Reader 替代品都逐渐稳定的现在，我已经过渡到&lt;a href="http://www.feedly.com"&gt;feedly&lt;/a&gt;上了。
老实说，虽然现在 Reader 满天飞，能真正像 Google Reader 那样舒适的着实不多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能订阅长城外的博客；&lt;/li&gt;
&lt;li&gt;访问迅速；&lt;/li&gt;
&lt;li&gt;稳定可靠；&lt;/li&gt;
&lt;li&gt;界面简洁实用；&lt;/li&gt;
&lt;li&gt;多终端支持；&lt;/li&gt;
&lt;li&gt;保存网站历史存档；&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中第一个是起码的(长城喜欢技术博不是一天两天了)，而最后那个是最难能可贵的。
对于那些已经消失了的博客站点，它们的痕迹只能残留在 Google Reader 的 RSS 列表中了。
而随着 Google Reader 的关闭，这些痕迹恐怕也会消影无踪吧。
就算有些博客没有消失，很多新的 Reader 们也只能抓到最近的文章，一些老的文章只能自己去博客上查而不能在 Reader 里看到。
对于那些发帖间隔很长但是都很值得一看的博客来说是很麻烦的。&lt;/p&gt;
&lt;p&gt;目前的替代品中，能像 Google Reader 这样保留站点历史存档的几乎没有。
Feedly 目前是基于 Google Reader 的后端所以还能看到。
他们自称有从 Google Reader 平滑迁移的计划(名字很不错，叫“诺曼底计划”)。
但是我不确定这个迁移是否包括所有历史存档——感觉如果包括历史存档的话，这个工程确实太大了。
而且考虑到像 Google 这样的公司也能作出这样的决定，还是把数据掌握在自己的手里比较放心一些。
于是还是自己随便写个爬虫抓来比较好吧。&lt;/p&gt;
&lt;p&gt;昨晚查了些资料，今早起床后写完后就运行然后去上课了，回来发现跑完了&lt;code&gt;_(:з」∠)_&lt;/code&gt;
代码在&lt;a href="https://github.com/skydark/grarchive"&gt;github&lt;/a&gt;上，
有需要的话自己改吧，我已经够用了(不负责摊手)……&lt;/p&gt;
&lt;h2&gt;使用方法(虽然我觉得除了我自己没人会用)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于&lt;code&gt;python2&lt;/code&gt;,需要如下扩展：&lt;code&gt;requests&lt;/code&gt;和&lt;code&gt;lxml&lt;/code&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;克隆仓库后，修改开始处的&lt;code&gt;USERNAME&lt;/code&gt;和&lt;code&gt;PASSWORD&lt;/code&gt;为自己的 Google 帐号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;a href="https://www.google.com/takeout/#custom:reader"&gt;Google&lt;/a&gt;导出 Google Reader 的数据，解压其中的&lt;code&gt;subscriptions.xml&lt;/code&gt;到仓库中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行&lt;code&gt;grarchive.py&lt;/code&gt;，然后睡一觉，如果没有出错，醒来时备份的xml会按分类和标题出现在&lt;code&gt;outdir&lt;/code&gt;目录中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;感谢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/askedrelic/libgreader"&gt;libgreader&lt;/a&gt; 只是借用了下 Google 登录；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://adityanag.com/journal/2012/02/20/using-the-google-reader-api-to-build-a-historical-archive-of-a-site/"&gt;这篇文章&lt;/a&gt;中介绍了关于抓取 Google Reader 历史记录的方法，我的脚本里没有处理超过1000条帖子的情况(因为不属于我关心的需要备份的部分)，这里也有介绍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://linuxtoy.org/archives/inoreader.html"&gt;Linuxtoy&lt;/a&gt; 见评论区&lt;code&gt;_(:з」∠)_&lt;/code&gt;我承认我从那时起一直在头疼(生理意义上)，而且到现在还没有完全恢复(摔)……&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;已知问题&lt;/h2&gt;
&lt;p&gt;显然，就是因为我一次运行成功了就懒得做的东西，所以别指望我做……&lt;code&gt;_(:з」∠)_&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单线程，我备份下来的文件有400M+，别问我具体用了多少时间，我说了我去上课了……；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无错误恢复过程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只支持单层分类，多层分类会被展开——显然因为我只有单层分类……；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按标题保存文件名，在遇到特殊标题会有麻烦——如果不是&lt;code&gt;unix&lt;/code&gt;系用户，可能需要更改&lt;code&gt;grarchive.py&lt;/code&gt;中的&lt;code&gt;normalize&lt;/code&gt;函数，用于将标题转换为文件名；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OAuth登录(虽然&lt;code&gt;libgreader&lt;/code&gt;中是有的)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个博客只输出1000篇文章，如需要实现见感谢里的第二个链接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输出修饰后的网页(而不是原始的xml——从备份角度我足够了所以懒得弄)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;……&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，这篇日志的目的就是记录下自己解决这个问题的要点和注意……啥，真有人以为那github仓库里的代码值得拿来用？(金馆长扶额脸)&lt;/p&gt;
</summary><category term="python"></category><category term="programming"></category></entry><entry><title>使用 Python 简单的自顶向下解析</title><link href="http://blog.skydark.info/programming/2013/02/24/top-down-parser/" rel="alternate"></link><published>2013-02-24T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2013-02-24:programming/2013/02/24/top-down-parser/</id><summary type="html">&lt;p&gt;译自&lt;a href="http://effbot.org/zone/simple-top-down-parsing.htm"&gt;http://effbot.org/zone/simple-top-down-parsing.htm&lt;/a&gt;, 一篇老文章了，好像没人译(因为很好懂大概)。
自己弄一遍希望能更清楚一些。&lt;/p&gt;
&lt;p&gt;Douglas Crockford 大牛的&lt;a href="http://javascript.crockford.com/tdop/tdop.html"&gt;文章&lt;/a&gt;似乎更出名些， &lt;a href="http://ghsky.com/2012/03/tdop.html"&gt;翻译&lt;/a&gt;也挺不错的。
不过那篇文章因为要实现一个 JavaScript 解析器，除了解析技术外其它部分稍有点分神。
这篇文章则更加关注于解析技术，并且更为循序渐进些。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/"&gt;这篇相关文章&lt;/a&gt;也是很不错的。&lt;/p&gt;
&lt;hr&gt;
&lt;div markdown="1" class="alert alert-danger"&gt;
&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;我不懂翻译，下面都是我瞎编的，现在我编不下去了……&lt;/strong&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;div id='toc-here'&gt;&lt;/div&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;使用 Python 简单的自顶向下解析&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://effbot.org/zone/simple-top-down-parsing.htm"&gt;http://effbot.org/zone/simple-top-down-parsing.htm&lt;/a&gt;
by Fredrik Lundh, July 2008&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://effbot.org/zone/simple-iterator-parser.htm"&gt;简单的基于迭代器解析&lt;/a&gt;一文中，
我描述了在 Python 中通过传递当前词素和词素生成函数的方式来编写简单递归下降解析器的一种方法。&lt;/p&gt;
&lt;p&gt;一个递归下降解析器由一系列函数构成，通常每个函数对应一条语法规则。
这类解析器容易编写，并且足够有效率，只要语法是“前缀密集的”；
即，通过查看一个构造最开头的词素便往往足够断定该去调用哪个解析函数。
举例来说，如果你在解析 Python 代码，通过查看首个词素便可简单地识别绝大多数语句。&lt;/p&gt;
&lt;p&gt;然而，递归下降法用于表达式语法是低效的，特别对有许多不同优先级的运算符的语言来说。
介于每条规则对应一个函数，你很容易陷入重重调用中，甚至对简短、平凡的表达式亦是如此，仅仅为了达到语法中合适的层级。&lt;/p&gt;
&lt;p&gt;举例而言，这儿是 Python 的表达式语法的一个片段。
“test” 规则是一个基本表达式元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test: or_test ['if' or_test 'else' test] | lambdef
or_test: and_test ('or' and_test)*
and_test: not_test ('and' not_test)*
not_test: 'not' not_test | comparison
comparison: expr (comp_op expr)*
expr: xor_expr ('|' xor_expr)*
xor_expr: and_expr ('^' and_expr)*
and_expr: shift_expr ('&amp;amp;' shift_expr)*
shift_expr: arith_expr (('&amp;lt;&amp;lt;'|'&amp;gt;&amp;gt;') arith_expr)*
arith_expr: term (('+'|'-') term)*
term: factor (('*'|'/'|'%'|'//') factor)*
factor: ('+'|'-'|'~') factor | power
power: atom trailer* ['**' factor]
trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这个文法的一个原始的递归下降实现，为了解析一个简单的函数调用(具有形式“expression(arglist)”)，解析器将不得不一路从“test”下降到“trailer”。&lt;/p&gt;
&lt;p&gt;在七十年代初期，Vaughan Pratt 在他的论文&lt;a href="http://doi.acm.org/10.1145/512927.512931"&gt;自顶向下算符优先级(Top-down Operator Precedence)&lt;/a&gt;中发表了一种对递归下降法的优雅改进。
Pratt 的算法将语义与词素(而不是语法规则)相关联，
并使用一种简单的“绑定力(binding power)”机制来处理优先级。
传统的递归下降解析则用来处理语法中奇特或不规则的部分。&lt;/p&gt;
&lt;p&gt;在与之同名的&lt;a href="http://javascript.crockford.com/tdop/tdop.html"&gt;文章&lt;/a&gt; (以及&lt;a href="http://oreilly.com/catalog/9780596510046/"&gt;图书章节&lt;/a&gt;) 中，
Douglas Crockford 展示了怎样在 JavaScript 的一个子集中实现这个算法，
并在此过程中用它来开发一个能够解析自己的解析器。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我会稍微谦逊一些：我将简要地解释算法如何工作，讨论在 Python 中通过它实现解释器和翻译器的不同方法，
并最终使用它实现一个 Python 的表达式语法的解析器。
并且当然，还会有基准测试。&lt;/p&gt;
&lt;h2&gt;介绍算法&lt;/h2&gt;
&lt;p&gt;和其它大多数解析器一样，自顶向下解析器操作一个不同语法单元/词素构成的流。
例如，表达式&lt;code&gt;1 + 2&lt;/code&gt;可以对应于如下词素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;值为 1 的字面量
运算符 +
值为 2 的字面量
程序结束&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在自顶向下算法中，每个词素有两个相关的函数，称作“nud”和“led”；还有一个整值称作“lbp”。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nud&lt;/code&gt;函数(空指称)在词素于某个语言构造的开头出现时使用，
而&lt;code&gt;led&lt;/code&gt;函数(左指称)则用于词素出现在构造中间时(即，相对于它在结构中剩余部分的左侧)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lbp&lt;/code&gt;值指绑定力，它控制算符优先级；
该值越高，词素与其紧随的词素间的绑定就越紧密。&lt;/p&gt;
&lt;p&gt;给出这样简短的介绍后，我们已经做好了观察 Pratt 的算法核心——表达式解析器的准备：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rbp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;rbp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lbp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;
        &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Pratt 将这个函数称作&lt;code&gt;parse&lt;/code&gt;, 但我们将替而使用 Crockford 的文章中使用的名字。)&lt;/p&gt;
&lt;p&gt;这里，&lt;code&gt;token&lt;/code&gt;是一个包含当前词素的全局变量，
&lt;code&gt;next&lt;/code&gt;则是一个获取下一个词素的全局助手函数。
&lt;code&gt;nud&lt;/code&gt;和&lt;code&gt;led&lt;/code&gt;函数被描述为方法，&lt;code&gt;lbp&lt;/code&gt;则是一个属性。
最后，&lt;code&gt;left&lt;/code&gt;变量被用于将表示表达式左半部分的值传递到&lt;code&gt;led&lt;/code&gt;方法；
这可以是任何对象，例如中间结果(对解释器来说)或者一部分解析树(对编译器来说)。&lt;/p&gt;
&lt;p&gt;如果将解析器应用到之前展示的简单表达式上，它将从调用第一个词素的&lt;code&gt;nud&lt;/code&gt;方法开始。
在我们的例子中，该词素是一个字面量，可以被类似如下的类表示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;literal_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，解析器检查下一个词素的绑定力是否至少有给定的绑定力(即&lt;code&gt;rbp&lt;/code&gt;实参，代表“右绑定力”)那么大。
如果有，则调用该词素的&lt;code&gt;led&lt;/code&gt;方法。
在这里，右绑定力是零，并且下一个词素是一个如下实现的算符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_add_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该算符有绑定力10, 且有一个&lt;code&gt;led&lt;/code&gt;方法再次调用表达式解析器，该方法传递与该算符自己绑定力相同的右绑定力。
这导致表达式解析器对子表达式使用更高的绑定力对待，并返回其值。
该方法接着将&lt;code&gt;left&lt;/code&gt;的值(在此情况下它来自字面量)与表达式解析器的返回值相加，并返回结果。&lt;/p&gt;
&lt;p&gt;程序结束由一个绑定力为零(低于所有其他词素)的特殊标记词素指示。
这确保表达式解析器在达到程序末尾时停止。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;end_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是整个解析器。
为了使用它，我们需要一个能够对给定源程序生成正确类别的词素对象的词法分析器。
这里是一个简单的基于正则表达式的版本，能处理我们此时已用到的最小语言：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;

&lt;span class="n"&gt;token_pat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\s*(?:(\d+)|(.))&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tokenize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;token_pat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;literal_token&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;operator_add_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unknown operator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;end_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，让我们接通并试验它吧：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;
    &lt;span class="nb"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 + 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不计入调用词法分析器的次数的话，解析器算法为解析这个表达式将总共进行四次调用；
每个词素调用一次，表达式解析器在&lt;code&gt;led&lt;/code&gt;方法中还有一次额外的递归调用。&lt;/p&gt;
&lt;h3&gt;扩充解析器&lt;/h3&gt;
&lt;p&gt;为了理解怎样扩充它，我们再来添加一点数学运算符。
我们需要更多一点类：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_sub_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_mul_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_div_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意&lt;code&gt;mul&lt;/code&gt;和&lt;code&gt;div&lt;/code&gt;比起其它运算符使用更高的绑定力；
这保证当&lt;code&gt;mul&lt;/code&gt;运算符在表达式&lt;code&gt;1 * 2 + 3&lt;/code&gt;中被调用时，它仅得到字面量&lt;code&gt;2&lt;/code&gt;,而不是将&lt;code&gt;2 + 3&lt;/code&gt;视为子表达式对待。&lt;/p&gt;
&lt;p&gt;我们还需要添加词法分析器的类别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tokenize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;token_pat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;literal_token&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;operator_add_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;operator_sub_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;operator_mul_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;operator_div_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unknown operator)&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;end_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后这就成了。
解析器现在理解了四种基本数学运算，并且正确地处理它们的优先顺序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2*3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2-3*4/5&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管事实上我们添加了更多的语法规则，解析器仍然和以前一样产生相同数量的函数调用；
在解析器中表达式&lt;code&gt;1 + 2&lt;/code&gt;仍然由四次调用处理。&lt;/p&gt;
&lt;p&gt;然而，从代码角度来说，这与递归下降解析器相比并没那么不同。
我们仍然需要为每个词素类编写代码，并且尽管我们从表达式解析器的单独的规则中移除了大多数分发代码，
这些代码大多最终出现在词法分析器的庞大的&lt;code&gt;if/else&lt;/code&gt;语句中。&lt;/p&gt;
&lt;p&gt;在我们关注避免这类代码的方法之前，让我们给解析器再添加两个特性：
一元加/减算符，以及 Python 样式的幂算符(&lt;code&gt;**&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;为了支持一元运算符，我们所需的一切仅仅是为相关词素添加&lt;code&gt;nud&lt;/code&gt;实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_add_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_sub_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意对&lt;code&gt;expression&lt;/code&gt;的递归调用使用了高绑定力，以保证一元运算符绑定到右边紧邻的词素上，而不是表达式的剩余部分(&lt;code&gt;(-1)-2&lt;/code&gt;和&lt;code&gt;-(1-2)&lt;/code&gt;是不同的)。&lt;/p&gt;
&lt;p&gt;添加幂运算有一点小技巧；首先，我们需要调整词法分析器来识别两个字符的运算符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;token_pat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\s*(?:(\d+)|(\*\*|.))&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;**&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;operator_div_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个稍大的问题是该运算符是右结合性的(即它绑定到右边)。
如果你在 Python 提示符中输入&lt;code&gt;2**3**4&lt;/code&gt;，Python 将首先求值&lt;code&gt;3**4&lt;/code&gt;那部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="il"&gt;2417851639229258349412352L&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;4096&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="il"&gt;2417851639229258349412352L&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;幸运地是，绑定力机制很容易实现这个；
为了得到右结合性，只需在递归调用时将运算符的绑定力减一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_pow_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这种方式，解析器将把随后的幂运算符(有绑定力30)视作当前表达式的子表达式，这正是我们想要的。&lt;/p&gt;
&lt;h2&gt;构建解析树&lt;/h2&gt;
&lt;p&gt;自顶向下方案的一个很好的侧效应是它很容易构建解析树而不带来很多额外的开销；
由于词法分析器为每个词素创建一个新对象，我们可以将这些对象重用为解析树的节点。&lt;/p&gt;
&lt;p&gt;为了实现这个，&lt;code&gt;nud&lt;/code&gt;和&lt;code&gt;led&lt;/code&gt;方法得在对象上添加语法树信息，并返回对象本身。
在接下来的例子中，字面量叶节点有属性&lt;code&gt;value&lt;/code&gt;，运算符节点有属性&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;。
类也有&lt;code&gt;__repr__&lt;/code&gt;方法用于使结果树更容易被查看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;literal_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(literal &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_add_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(add &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_mul_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(mul &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(实现&lt;code&gt;sub&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;和&lt;code&gt;pow&lt;/code&gt;被留作练习。)&lt;/p&gt;
&lt;p&gt;在新的词素实现下，解析器将返回解析树：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2+3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2*3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1*2+3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一元加在树中插入一个“一元加”节点(&lt;code&gt;second&lt;/code&gt;属性被设置为&lt;code&gt;None&lt;/code&gt;)。
如果你愿意，你可以跳过额外的节点，在&lt;code&gt;nud&lt;/code&gt;中简单返回内部表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;operator_add_token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是否是个好主意有赖于你的语言定义(比方说Python, 一般情况下就不会把它们优化掉，以防你在不是数字的东西上使用一元加)。&lt;/p&gt;
&lt;h2&gt;简化词素类生成&lt;/h2&gt;
&lt;p&gt;我们至今为止使用的简单解析器都由许多类构成，每个词素各一个，词法分析器对它们则全都了解。
Pratt 替而使用关联数组，并将运算符与其词素关联起来。
在 Python 中，这看起来类似于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="n"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;lbp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这有点笨拙，并且从 Python 的角度看有那么点倒退。
Crockford 的 JavaScript 实现使用了不同的方法：
他使用单独的“词素类注册表”(他将其称作“符号表”)，和一个在线创建新类的工厂函数。
JavaScript 的原型模型使得这样做不可思议地简单，但在 Python 中在线生成类也不那么难。&lt;/p&gt;
&lt;p&gt;首先，让我们引入词素类型的基类，用于留个地方来塞公共行为。
我添加了用于存储词素类型名(&lt;code&gt;id&lt;/code&gt;属性)和词素值(对字面量和命名词素)的默认属性，还有一些用于语法树的属性。
这个类也是个给&lt;code&gt;nud&lt;/code&gt;和&lt;code&gt;led&lt;/code&gt;方法提供默认实现的合适场所。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;symbol_base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# node/token type name&lt;/span&gt;
    &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# used by literals&lt;/span&gt;
    &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;third&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# used by tree nodes&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;Syntax error (&lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s2"&gt;).&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;Unknown operator (&lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s2"&gt;).&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(name)&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;third&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们需要一个词素类型工厂：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol_table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;s&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol_base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;pass&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;symbol-&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="c1"&gt;# for debugging&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;
        &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lbp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lbp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数接受一个词素标识符和一个可选的绑定力，并在必要时创建一个新类。
标识符和绑定力被作为类属性插入，并将在该类的所有实例中有效。
如果该函数为一个已注册的符号调用，它仅仅更新绑定力；
这允许我们在不同的地方定义符号之行为的不同部分，我们将稍后看到。&lt;/p&gt;
&lt;p&gt;现在我们可以向注册表填入我们将要使用的符号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;**&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(end)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了简化分发，我们使用词素字符串作为标识符；
符号&lt;code&gt;(literal)&lt;/code&gt;和&lt;code&gt;(end)&lt;/code&gt;(分别代替之前使用的&lt;code&gt;literal_token&lt;/code&gt;和&lt;code&gt;end_token&lt;/code&gt;类)的标识符是不会作为原始词素出现的字符串。&lt;/p&gt;
&lt;p&gt;我们还需要更新词法分析器，来使之使用注册表中的类：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tokenize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;token_pat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Unknown operator&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(end)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和之前一样，字面量类用作所有字面量值的公共类。
所有其他词素拥有自己的类。&lt;/p&gt;
&lt;p&gt;现在，所有剩下的事情就是为需要附加行为的符号定义&lt;code&gt;nud&lt;/code&gt;和&lt;code&gt;led&lt;/code&gt;方法。
为了完成它，我们可以将它们定义为普通函数，然后简单地将其一个个塞入符号类。
例如，这是加法的&lt;code&gt;led&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一行从符号注册表中取得类，并将函数添加给它。
这里是更多一点&lt;code&gt;led&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它们看起来都相当相似，不是吗？唯一不同的是绑定力，所以我们可以通过将重复代码移入一个助手函数来把事情再简化一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过给出这个助手函数，我们现在可以将上面的&lt;code&gt;led&lt;/code&gt;函数替换为四个简单调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似地，我们可以为&lt;code&gt;nud&lt;/code&gt;方法和右结合性提供助手函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nud&lt;/span&gt;

&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;infix_r&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
    &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;

&lt;span class="n"&gt;infix_r&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;**&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，字面量符号必须符合一个返回符号自身的&lt;code&gt;nud&lt;/code&gt;方法。
为此我们可以使用一个平坦的&lt;code&gt;lambda&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到以上大部分都是一般用途的管道装置：通过给出助手函数，实际的解析器定义浓缩为以下六行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;infix_r&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;**&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(end)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行它将产生和之前相同的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2+3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2*3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1*2+3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解析 Python 表达式&lt;/h2&gt;
&lt;p&gt;为了给出稍微大点的例子，让我们调整解析器使之能解析 Python 的表达式语法的一个子集，类似于本文开始时的语法片段给出的语法。&lt;/p&gt;
&lt;p&gt;为了做到这个，我们首先需要一个更时髦的词法分析器。
基于 Python 的&lt;code&gt;tokenize&lt;/code&gt;模块是显然的选择：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tokenize_python&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;tokenize&lt;/span&gt;
    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;cStringIO&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;StringIO&lt;/span&gt;
    &lt;span class="n"&gt;type_map&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NUMBER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;STRING&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OP&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(operator)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(name)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;generate_tokens&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StringIO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;type_map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ENDMARKER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Syntax error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(end)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(end)&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tokenize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;tokenize_python&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# name or operator&lt;/span&gt;
            &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(name)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Unknown operator (&lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个词法分析器分为两部分；
一个语言特定的解析器将源程序转换为字面量、命名和运算符的流，第二部分再将它们转换为词素实例。
后者同时在符号表中核对运算符和命名(为了处理关键字运算符)，并为所有其他命名使用伪符号(&lt;code&gt;(name)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;你可以将两个任务合并为一个函数，但是分隔开使得测试解析器变得稍微容易些，而且还使得为其它语法重用第二部分成为可能。&lt;/p&gt;
&lt;p&gt;我们可以使用老的解析器定义测试新的词法分析器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2+3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2*3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1.0*2+3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;#39;hello&amp;#39;+&amp;#39;world&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新的词法分析器支持更多种类的字面量，所以我们的解析器不必做任何额外工作也能支持了。
而且我们仍然在使用我们在本文开头介绍的 10 行的表达式实现。&lt;/p&gt;
&lt;h3&gt;Python 表达式语法&lt;/h3&gt;
&lt;p&gt;好，让我们对语法做点什么。
我们可以从之前展示的语法片段中推出正确的表达式语法，但在 Python 的语言参考的“求值顺序”一节中还有更实用的描述。
该节中的表格按优先顺序从低至高地列出了所有表达式运算符。
这儿是对应的定义(绑定力从20开始)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;lambda&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;if&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 三元形式&lt;/span&gt;

&lt;span class="n"&gt;infix_r&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;or&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix_r&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;and&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;in&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# in, not in&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;is&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# is, is not&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;!=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;==&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;|&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;^&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;amp;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;&amp;lt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;110&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;110&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;//&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;infix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;%&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;infix_r&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;**&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;140&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;150&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;150&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;150&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这16行定义了35个运算符的语法，并且还提供了它们中绝大多数的行为。&lt;/p&gt;
&lt;p&gt;尽管如此，符号助手定义的词素并没有固有的行为；
为了使之运转，还需要添加代码。
还有一些由于 Python 的词法分析器的限制引起的复杂性。
更多这方面的事情稍后再说。&lt;/p&gt;
&lt;p&gt;但在我们开始忙活那些符号前，我们还需要给伪词素们添加行为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(name)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(end)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以做一个快速的完整性检查：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;lt;&amp;lt;3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;括号表达式&lt;/h3&gt;
&lt;p&gt;让我们把关注点转移到剩下的符号，并从简单的事情开始：括号表达式。
它们可以通过在&lt;code&gt;(&lt;/code&gt;词素上的&lt;code&gt;nud&lt;/code&gt;方法实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nud&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用到的&lt;code&gt;advance&lt;/code&gt;函数是一个在获取下一个词素前检查当前词素拥有给定值的助手函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Expected &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;词素&lt;code&gt;)&lt;/code&gt;必须被注册；若不然，词法分析器将把它报告成一个无效词素。
为了注册它，只需要调用&lt;code&gt;symbol&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们来试验一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2*3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(1+2)*3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到&lt;code&gt;nud&lt;/code&gt;方法返回内部表达式，所以&lt;code&gt;(&lt;/code&gt;节点不会出现在结果语法树中。&lt;/p&gt;
&lt;p&gt;同样提醒一下，我们在这里暂时作了个弊：
前缀&lt;code&gt;(&lt;/code&gt;在 Python 中有两种含义；
它既可以像上面那样用来分组，也可以用来创建元组。
我们下面再修复这个问题。&lt;/p&gt;
&lt;h3&gt;三元运算符&lt;/h3&gt;
&lt;p&gt;大多数定制方法看起来多少就像它们在递归下降法中对应的部分，行内&lt;code&gt;if-else&lt;/code&gt;的代码也没有什么不同：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;else&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;third&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;if&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再一次，在我们可以试验它之前我们需要注册额外的词素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;else&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 if 2 else 3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;属性与项查找&lt;/h3&gt;
&lt;p&gt;为了处理属性查找，“.”运算符需要一个&lt;code&gt;led&lt;/code&gt;方法。
为了方便，这个版本验证点号随后的是合适的命名词素(这项检查也可以在之后的步骤中进行)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(name)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Expected an attribute name.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo.bar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项访问是类似的；只需要为&lt;code&gt;[&lt;/code&gt;运算符添加&lt;code&gt;led&lt;/code&gt;方法。
由于&lt;code&gt;]&lt;/code&gt;是语法的一部分，我们还需要注册它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;#39;hello&amp;#39;[0]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;([&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到我们正陷入大量这种形式的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这有点不方便，不是因为别的而是因为它违背了“不要重复你自己”的规则(方法名出现了三次)。
用一个简单的装饰器解决之：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;issubclass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;symbol_base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;setattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个装饰器手机函数名，并将其附加到给定符号上。
它将符号名放在方法定义之前，并仅需要你写一次方法名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在接下来的例子中将使用它。
由于另一种方式并不长多少，所以如果你需要针对 Python 2.3 或更老的版本你仍然可以使用它。
就是要小心打字错误。&lt;/p&gt;
&lt;h3&gt;函数调用&lt;/h3&gt;
&lt;p&gt;一个函数调用由一个表达式和一个在括号中的由逗号分隔的表达式列表构成。
通过将左括号视为二元运算符，解析起这个来简单易懂：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello(1,2,3)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里稍微简化了点；这个版本并不支持关键字实参和&lt;code&gt;*&lt;/code&gt;与&lt;code&gt;**&lt;/code&gt;形式。
为了处理关键字实参，在第一个表达式后查找&lt;code&gt;=&lt;/code&gt;，要是找到了，检查子树是否是一个平坦的命名，接下来再次调用&lt;code&gt;expression&lt;/code&gt;以取得默认值。
另一种形式可以被对应运算符的&lt;code&gt;nud&lt;/code&gt;方法处理，但在这个方法中处理这些大概更容易。&lt;/p&gt;
&lt;h3&gt;Lambdas&lt;/h3&gt;
&lt;p&gt;Lambdas 也相当简单。
由于&lt;code&gt;lambda&lt;/code&gt;关键字是前缀运算符，我们将通过&lt;code&gt;nud&lt;/code&gt;方法实现它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;lambda&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;argument_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;argument_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(name)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Expected an argument name.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;lambda a, b, c: a+b+c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再一次，实参列表有一点简化；
它并不处理默认值和&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;形式。
实现提示参考上面。
同样提醒在这个实现中没有解析器层面的作用域处理。
这个话题从 Crockford 的文章中可以了解更多。&lt;/p&gt;
&lt;h3&gt;常量&lt;/h3&gt;
&lt;p&gt;常量可以被当作字面量处理；接下来的&lt;code&gt;nud&lt;/code&gt;方法将词素实例更改为字面量节点，并把词素自己作为字面量的值插入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;(literal)&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;None&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;False&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 is None&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;True or False&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;多词素运算符&lt;/h3&gt;
&lt;p&gt;Python 有两个多词素运算符，&lt;code&gt;is not&lt;/code&gt; 和 &lt;code&gt;not in&lt;/code&gt;, 但我们的解析器并没有完全正确地对待它们：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 is not 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题在于标准的&lt;code&gt;tokenize&lt;/code&gt;模块并不理解这种语法，所以它很高兴地将这些运算符返回为两个分隔的词素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokenize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 is not 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换句话说，&lt;code&gt;1 is not 2&lt;/code&gt;被处理为&lt;code&gt;1 is (not 2)&lt;/code&gt;，而这并不是同一件事：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一种修复它的方式是调整词法分析器(即，通过在原生的 Python 解析器与词素实例工厂之间插入一个组合过滤器)，
但在&lt;code&gt;is&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;运算符上通过定制&lt;code&gt;led&lt;/code&gt;方法来修复大概更容易些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;not&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;in&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Invalid syntax&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;not in&amp;quot;&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;is&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;not&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;is not&amp;quot;&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 in 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 not in 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 is 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1 is not 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这意味着&lt;code&gt;not&lt;/code&gt;运算符能同时处理一元&lt;code&gt;not&lt;/code&gt;和二元&lt;code&gt;not in&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;元组，列表和词典表示&lt;/h3&gt;
&lt;p&gt;正如上面提醒的那样，&lt;code&gt;(&lt;/code&gt;前缀在 Python 中担当两种作用；
它被用于分组，还被用于创建元组(它也在函数调用中被用作二元运算符)。
为了处理元组，我们需要将&lt;code&gt;nud&lt;/code&gt;方法替换为能够区分元组和平坦括号表达式的版本。&lt;/p&gt;
&lt;p&gt;Python 的元组构成规则很简单；如果一对括号是空的，或者包括至少一个逗号，它是一个元组。
否则，它是一个表达式。或者换句话说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;() 是一个元组&lt;/li&gt;
&lt;li&gt;(1) 是一个括号表达式&lt;/li&gt;
&lt;li&gt;(1,) 是一个元组&lt;/li&gt;
&lt;li&gt;(1, 2) 是一个元组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这儿是实现这些规则的一个用于替换的&lt;code&gt;nud&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;comma&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="n"&gt;comma&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
            &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;comma&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="c1"&gt;# tuple&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;()&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(1)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(1,)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;(1, 2)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;列表和词典稍微容易点；它们仅仅是平坦的表达式列表或表达式对。
别忘了注册额外的词素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;[1, 2, 3]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;([&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;{&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;nud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;one&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;two&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;one&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;literal&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;two&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 Python 在创建列表、元组与词典时允许你使用可选的尾部逗号；
在收集循环开头的一个额外的&lt;code&gt;if&lt;/code&gt;语句能照顾到那种情况。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;尽管在我们可以声称完全支持 Python 2.5 的表达式语法前我们仍然还剩下一点要添加的东西，
但我们已经通过非常少的工作覆盖了语法中相当大的部分——大约 250 行代码(包含整个解析器机器)。&lt;/p&gt;
&lt;p&gt;而且正如我们贯穿本文所看到的那样，使用这种算法和实现方法的解析器是可读的，容易扩充，并且，如同我们一会儿将要看到的那样，令人惊讶地快。
尽管这篇文章关注于表达式，这种算法可以很容易地扩充到面向语句的语法上。
通过 Crockford 的文章可以了解一种完成它的方法。&lt;/p&gt;
&lt;p&gt;总而言之，Pratt 的解析算法是 Python 解析工具箱的很好的补充，本文中概括的实现策略则是快速实现那样的解析器的一种简单方式。&lt;/p&gt;
&lt;h2&gt;性能&lt;/h2&gt;
&lt;p&gt;如同我们已经看到的，解析器对每个词素仅使用很少的 Python 函数调用，这意味着它应该相当高效(或者像 Pratt 记录的，“假如不是理论上高效的话，至少实际上如此”)。&lt;/p&gt;
&lt;p&gt;为了测试实际性能，我从 Python FAQ 中挑选了一个 456 个字符长的 Python 表达式(大约 300 个词素)，并使用许多不同工具解析它。
这儿是在 Python 2.5 下的一些典型结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;自顶向下解析(到抽象语法树): 4.0 ms
内建解析(到元组树): 0.60 ms
内建编译(到 code 对象): 0.68 ms
编译器解析(到抽象语法树): 4.8 ms
编译器编译(到 code 对象): 18 ms&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们调整解析器使之能处理预先计算好的词素列表(通过运行&lt;code&gt;list(tokenize_python(program))&lt;/code&gt;获得)，
解析时间将降到仅仅 0.9 ms 以下。
换句话说，完全解析中仅有大约四分之一的时间花在了词素实例的创建、解析、构建树上。
剩下的几乎完全消耗在 Python 的&lt;code&gt;tokenize&lt;/code&gt;模块上。
通过更快的词法分析器，这个算法将达到与 Python 内置的词法分析器/解析器相比的2倍以内或差不多的时间。&lt;/p&gt;
&lt;p&gt;内建的解析测试本身相当有趣；它使用 Python 内部的词法分析器和解析器模块(二者都是用 C 写成的)，
并使用&lt;code&gt;parser&lt;/code&gt;模块(也是用 C 写成的)将内部语法树对象转换为元组树。
这很快，但结果是一个显然不可读的低级树：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st2tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;258&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;326&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;303&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;304&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;305&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;306&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;307&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;309&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;310&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;311&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;312&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;313&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;314&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;315&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;316&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;317&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))))),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;314&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;315&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;316&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;317&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)))))))))))))))),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(在这个例子中，2 表示数字，14 表示加，4 表示换行，0 是程序末尾。三位数表示 Python 语法的中间规则。)&lt;/p&gt;
&lt;p&gt;编译器解析测试替而使用&lt;code&gt;compiler&lt;/code&gt;包中的&lt;code&gt;parse&lt;/code&gt;函数；
这个函数使用 Python 内部的词法分析器和解析器，然后将返回的低级结构转化为更漂亮的抽象树：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;compiler&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;compiler&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1+2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;eval&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Expression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种转换(由 Python 完成)所需的工作被证明比用自顶向下解析器解析表达式还要多；
使用本文中的代码，我们可以使用 85% 的时间获得抽象语法树，尽管在用着一个相当慢的词法分析器。&lt;/p&gt;
&lt;h2&gt;代码注解&lt;/h2&gt;
&lt;p&gt;本文中的代码使用全局变量来维持解析器的状态(&lt;code&gt;token&lt;/code&gt;变量和&lt;code&gt;next&lt;/code&gt;助手函数)。
如果你需要一个线程安全的解析器，这些应该移动到一个上下文对象中。
这会导致轻微的性能损失，但有一些令人惊讶的为性能付出一点内存作的代价的方法来补偿。
更多这方面的内容见之后的文章。&lt;/p&gt;
&lt;p&gt;本文中展示的所有解释器和翻译器的代码都包含在本文当中了。
配套的代码范例也可以从这里获得：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://svn.effbot.org/public/stuff/sandbox/topdown"&gt;http://svn.effbot.org/public/stuff/sandbox/topdown&lt;/a&gt;&lt;/p&gt;
</summary><category term="python"></category><category term="programming"></category></entry><entry><title>Aqualang Notes</title><link href="http://blog.skydark.info/programming/2012/11/14/aqua_notes/" rel="alternate"></link><published>2012-11-14T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2012-11-14:programming/2012/11/14/aqua_notes/</id><summary type="html">&lt;p&gt;好吧，大概两个月没发东西了……从现状来看，我大概活着……
其实要是以前的话大概会没事发个现状总结给死党看，然则现在她在这儿没存在感……&lt;/p&gt;
&lt;p&gt;最近发生的比较 RP 的事情是今天知道自己在&lt;a href="http://www.ituring.com.cn/activity/details/15396"&gt;松本行弘访谈问题征集&lt;/a&gt;里中奖了!
大概是因为这辈子的 RP Point 全都积攒到了一些特殊事件上，从小到大从来没有中过什么奖，包括各种再来一瓶、再来一根、再来一袋、30% 送卤蛋什么的都是各种没中过……所以这次真心是这辈子第一次中奖2333
奖品是松本行弘签名的《松本行弘的程序世界》，虽然这书我早有一本读完了的XD&lt;/p&gt;
&lt;p&gt;&lt;img alt="签名书照" src="/images/matz_book.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;我提问的问题是这样的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class="well"&gt;设计语言的时候往往需要在很多语言特性中进行取舍，比如多继承和 Mixin，比如基于类还是基于原型等等。对 Matz 先生来说，在设计 Ruby 的时候感到最难以取舍的、考察最深入的语言特性是什么？有没有哪个特性会让您觉得“啊，当年若是选择那么做而不是这么做，虽然不会是现在的 Ruby，但应该也不错”？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之所以会问这个问题，是因为自己的确正在想实现一个语言练练手。
在考察各种语言特性的时候(当然程序语言并不是特性的堆积)，总是觉得大多数时候这些特性没有绝对的对与错，而更多的是根据语言自身的特点和目的来进行的取舍和妥协。
显然我在很多这类的地方纠结了很久很久，所以想趁机请教下 Matz 大神，看他当年在这种事情上是怎么纠结的 :)
本来觉得这问题挺个人兴趣的，被选上的确出乎意料，可惜不能当场去听回答了XD&lt;/p&gt;
&lt;p&gt;更新:
Matz 的回答在&lt;a href="http://www.ituring.com.cn/article/17487"&gt;这里&lt;/a&gt;。
Matz 首先强调最重要的选择是静态语言和动态语言，这个略出乎我意料，不过应该是我没考虑好……
“当我想设计一种编程语言作为自己的工具来用的时候，我就觉得还是动态语言实际用起来比较好用”这点的确有同感。
Matz 还强调了 Mixin, 这个在预料之中，在那个年代选择这种设计确实是比较有挑战性的。
Matz 还感慨了下从 Perl 里拿的有点过了，这个的确是很明显的，那些 Perl 里很 magic 的 $XX 就都拿过来了，要说方便是方便，但也太 magic 了点。
这个也的确值得警醒，不要从要参考的语言里拿太多XD&lt;/p&gt;
&lt;p&gt;顺便感慨句，Matz 太懂中国了233&lt;/p&gt;
&lt;p&gt;其实本来最近就想就自己对想实现的 Toy language 的各种考量写个 Note 的(记性奇烂无比，已发生过几个月前考虑过的问题不得不再考虑一次的窘境，所以干脆记下来的好)，既然挨上好事了，就先占个位子慢慢来……
当然读者必然假定是未来的自己了，如果在读这段文字的恰好是未来的我，麻烦从 金馆长脸/姚明脸/兔斯基以头抢砖 表情中选一个，现在的我推荐姚明脸……&lt;/p&gt;
&lt;p&gt;最后一次更新是 2012/11/14.
显然最近这事的优先级不高，下次更新不排除隔周啥的2333&lt;/p&gt;
&lt;hr /&gt;
&lt;p class="btn btn-primary" id="show_all"&gt;展开所有项目&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="meta-questions"&gt;Meta Questions&lt;/h2&gt;
&lt;h3 id="_1"&gt;为什么大多数问题的回答都是“因为我懒……”?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为我现在懒……&lt;/li&gt;
&lt;li&gt;事实是我急着睡觉，而大部分问题我嫌敲起来麻烦还没整理到这里……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;为什么问题明显不足，有些问题明显标题都没起好?&lt;/h3&gt;
&lt;p&gt;因为我懒……&lt;/p&gt;
&lt;h3 id="aqua"&gt;为何起名为 Aqua?&lt;/h3&gt;
&lt;p&gt;一开始有想法的时候其实想起名为 Jade 的，因为曾经在绯月上看过 haibara 大他们的讨论，说过“既然日本有 Ruby，中国就叫 Jade 吧XD”，不过 Jade 已经是比较知名的语言了所以作罢。&lt;/p&gt;
&lt;p&gt;后来一直在用的称呼是 Lotus, 因为打算之后在其上构建一套叫 Dark Crow 的系统，熟悉加速世界的应该能对这个典故一目了然……
缺点很明显，大名鼎鼎的 Lotus Note 已经占掉了 Lotus Script 这个名号，所以在真正开始实现之前只是以此为代名。
(P.S.:最近刚听说 IBM 要把 Lotus 撤了？)&lt;/p&gt;
&lt;p&gt;Matz 在他的程序世界一书中曾强调名字的重要性，王培在他的通用人工智能课程上也强调为组合概念起名字的重要性，这方面我一直深感赞同。
没有名字的东西是没法深入讨论的，只有起了名字，才能脱离原有的表面的理解，去探究更多细致的特性。
连代号都没有的话，心里想“这个语言要满足这样的特点”的时候，就只能“这个”“这个”的叫，也怪别扭的。&lt;/p&gt;
&lt;p&gt;现在这个名字 &lt;em&gt;Aqua&lt;/em&gt; 是某天晚上决心开始动手时紧急起的，一方面比较简单易记，一方面似乎没有太出名的重名语言。
水本身既沉稳安逸，也有灵活多变的一面，也符合我希望这个语言满足的特点。
此外 Aqua 也是黑暗星云的成员之一，而我的星座也是瓶子。
做为毫无艺术细胞的我，这样随便撞脑门起了这样的名字，似乎也算是合格了吧。&lt;/p&gt;
&lt;h2 id="implement"&gt;Implement&lt;/h2&gt;
&lt;h3 id="vm"&gt;为何选择 VM 而不是解释或编译?&lt;/h3&gt;
&lt;p&gt;从个人感受而言，我是认为真正的程序语言是解释的，编译是根据可以静态推断的信息进行的一种优化。
不过这里的语言，应该是指脱离了纯文本语法层面的语言，至少在 AST 层面上的。&lt;/p&gt;
&lt;p&gt;话虽这么说，设计程序语言这种事情就是要做各种 trade off 的……
从现阶段来说，使用 VM 实现我能想象到的好处有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我可以在 VM 这边玩很长时间而不用去考虑 parser 和 bytecode compiler 的实现: 前端那边因为语法未定而变化很快，而 VM 这边确定主要特性后基本可以动手了，也不必担心前端变化带来的影响太大。&lt;/li&gt;
&lt;li&gt;移植方便，parser 不移植都可以，只要用 aqua 自己写一个 parser 就可以了，这一点后头还会提到。&lt;/li&gt;
&lt;li&gt;事实上，上面都是骗人的……其实是以前我在脑补 continuation 的实现的时候基于 VM 的方式几乎是立刻想到了，但是基于 AST 解释的方式卡在了奇怪的地方，然后我恰好选择在这个时候第一次动手了……虽然后来我又不打算实现 continuation 了233333333&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="python"&gt;为何选择使用 Python 实现?&lt;/h3&gt;
&lt;p&gt;基于高级语言实现的最大优势是站的高看的远，很多时候不必在细节上浪费功夫。
尤其是现在还在设计阶段，大把大把的变化，放在 Python 里能省不少笔墨。&lt;/p&gt;
&lt;p&gt;基于高级语言的最大缺点就是性能。
对于设计阶段的 Aqua 来说，开发快速原型并迅速更改，要比效率问题重要太多了。
另一方面，PyPy 在设计动态语言方面表现突出，具体可以看他们的 &lt;a href="http://doc.pypy.org/en/latest/extradoc.html"&gt;paper&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;另一个问题是可移植性。Python 还算平台众多。而且最关键的是这只是个原型设计，重写在必要时是会提上议程的，前提是用户不再只是我一个，这个有点不现实233&lt;/p&gt;
&lt;p&gt;嘛，其实我又在骗人了……我只是不想考虑 GC 而已233333
虽然从现在的实现来看，如果考虑 GC 的确会很折寿……
这至少说明使用 Python 减少了我因为实现难度而放弃特性的可能。&lt;/p&gt;
&lt;h2 id="syntax"&gt;Syntax&lt;/h2&gt;
&lt;h3 id="python_1"&gt;为何选择接近 Python 的语法?&lt;/h3&gt;
&lt;p&gt;首先，接近 Python 显然是因为我很喜欢 Python 风格的代码，清晰易读废话少:)&lt;/p&gt;
&lt;p&gt;至于为什么接近到很多地方几乎完全兼容，其实主要是因为我有个很233的想法，就是希望 parser/bytecode compiler 既是合法的 Python(甚至 RPython) 代码，也是合法的 Aqua 代码。
这样的话就可以实现在 VM 层之上的 bootstrap 了。
而且这个 parser 也可以直接拿到 Aqua 里当作 eval 的一部分，也可以在没有 Aqua 的机器上使用 Python 直接为 Aqua 输出字节码，总之好处多多。&lt;/p&gt;
&lt;p&gt;至于 VM 端，如果可能也是 Python/Aqua 通吃的话那也最好，但考虑到还有运行时，另外 class 等的设计可能和 Python 有很大出入，大概不是很指望了。&lt;/p&gt;
&lt;h3 id="python_2"&gt;为何保留 Python 的缩进语法?&lt;/h3&gt;
&lt;p&gt;TODO: 整理中&lt;/p&gt;
&lt;p&gt;因为希望能让 Python 来启动 bootstrap, 自然要保留缩进XD
不过即使不考虑这个，我也会希望保留这点。&lt;/p&gt;
&lt;p&gt;处理缩进、调整 Tab 和空格、为了防止对错位置而折叠代码并提供参考线等功能明显应该是编辑器的工作。&lt;/p&gt;
&lt;p&gt;使用缩进规定语法的语言也有不少了，除了 Python, Haskell, F# 和 CoffeeScript 等语言也在用，我最喜欢的数据存储格式 YAML (这才是给人读的的格式！) 也在用。&lt;/p&gt;
&lt;p&gt;实际上，我认为语句中的大括号和表达式中的小括号一样，应该是一种类似调整优先级、消除歧义的功能。
大括号在需要的时候(缩进表达不清楚)可以加上，在不需要的时候(靠缩进就足够清楚)完全可以去掉。&lt;/p&gt;
&lt;p&gt;对于缩进的坏处，我见过的最靠谱的驳斥来自&lt;a href="https://yinwang0.wordpress.com/2011/05/08/layout/"&gt;王垠&lt;/a&gt;。
王垠认为在使用 Layout Syntax 时，由于对齐问题，导致犯错成本太低。
在移动代码块时，重新缩进变得不得不立刻操作。
而其优点，譬如代码更短、更少的括号更清晰等，又不甚明显。&lt;/p&gt;
&lt;p&gt;Parse 不方便。&lt;/p&gt;
&lt;p&gt;Layout Syntax 的另一个问题是嵌入其它语言中时很不方便，比如 Web 页面的模板。
不过这方面 Python 自己就有很多示范。
显然这个问题是能解决的，虽然大多嵌入的语言都做了一定的修改来适应。
我觉得这个问题还是个“大括号在缩进表达不清楚时可以加上”的问题。
只不过 Python 没有去考虑这个问题，导致模板语言设计者自己去解决了。&lt;/p&gt;
&lt;p&gt;总的来说，缩进本身自然是好的。
而将缩进强制规定到语法层面，和很多其它选择一样是一种 trade off.
而我认为这种交易是值得的。&lt;/p&gt;
&lt;h2 id="function-block"&gt;Function &amp;amp; Block&lt;/h2&gt;
&lt;h3 id="_3"&gt;有关变量作用域的判定&lt;/h3&gt;
&lt;p&gt;在各个语言中随便试验了一下与下面代码类似功能的代码:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;               &lt;span class="c1"&gt;# x1&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;# 哪一个 x?&lt;/span&gt;
        &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;             &lt;span class="c1"&gt;# 是否找的到 x?&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="c1"&gt;# x2&lt;/span&gt;
        &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;g 中的 x 指 x1: lua 和 go —— 不过 golang 在有不使用的变量的时候是无法通过编译的，所以要在比如 x2 后头 println 一下 x 什么的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;g 中的 x 指 x2: python, scheme(使用&lt;code&gt;define&lt;/code&gt;) 和 javascript(nodejs). Python 在第一次调用 g 时会因为 x2 尚未赋值而抛出异常。Scheme 这边，guile 的行为类似 python, racket 则类似 javascript;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态作用域: perl(local);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需要考虑这类问题: lisp 等，因为&lt;code&gt;let&lt;/code&gt;的作用域很明确; C 等也不需要考虑，因为没有嵌套函数;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ruby(lambda/proc) 和 coffee 有点特别。coffee 中类似这样写的话，x2 处的&lt;code&gt;x = 2&lt;/code&gt;实际上指的是给 x1 赋值为 2,所以 g 中的 x 指 x1, 但运行显示的是&lt;code&gt;12&lt;/code&gt;. Ruby 的 lambda/proc 和 coffee 这样设计应该是希望尽量&lt;a href="http://coffeescript.org/#lexical_scope"&gt;避免同名覆盖&lt;/a&gt;，不过也有令人困惑的地方：对 ruby 来说，还可以用&lt;code&gt;def&lt;/code&gt;来屏蔽作用域；但对于 coffee，至少我直到看到翻译后的 javascript 代码前确实没有预料到这里的&lt;code&gt;x = 2&lt;/code&gt;竟然是那样的作用，这样反而意外地修改了外部的 x 的值，尽管在需要闭包的地方的确会方便的多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="macro"&gt;Macro?&lt;/h3&gt;
&lt;p&gt;因为我懒……&lt;/p&gt;
&lt;h3 id="_4"&gt;模式匹配&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;模式匹配的价值&lt;/li&gt;
&lt;li&gt;有序/无序匹配&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="exception"&gt;Exception&lt;/h2&gt;
&lt;h3 id="_5"&gt;关于异常和返回值&lt;/h3&gt;
&lt;p&gt;这个问题几乎是 Go 语言掀到风头浪尖的。
Go 语言中取消了异常，转而使用 C 风格的返回值进行错误处理(尽管 Go 中仍然保留了 panic 用于从深层调用中跳出，但一般要求限制在包内部)。
Go 社区对此已有过&lt;a href="https://groups.google.com/forum/#!topic/golang-nuts/kqGL_2p_VCc/discussion[1-25]"&gt;热烈的争论&lt;/a&gt;
与此相关的文章也有很多。我个人最赞同&lt;a href="http://www.yosefk.com/blog/error-codes-vs-exceptions-critical-code-vs-typical-code.html"&gt;这篇文章&lt;/a&gt;的观点，即:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无论是使用异常还是使用返回值，人都是可能犯错的;&lt;/li&gt;
&lt;li&gt;一般情况下，使用异常相对而言更安全;&lt;/li&gt;
&lt;li&gt;但对严肃的、关键的、被严格审查的代码而言(尤其系统编程中)，使用返回值的代码更容易控制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是因为人天性是懒惰的，因此在不严肃的编程中(尤其脚本编程中)，忘记处理返回值和忘记处理异常都是可能的。
相比而言，忘记处理异常所产生的错误更为明显。
但是当需要仔细审查的时候，随处都有可能抛出异常的代码的控制流显然更加难以琢磨。
对于以 C 语言为主要对手(虽然现实是更多的脚本小子更有转行的看法XD)的 Go 语言而言，选择使用返回值处理错误完全可以理解。
因为对严肃的应用，非确定性的异常抛出是灾难性的。
但对于不严肃到那种程度的场合，使用异常相对而言是要痛快些，而且有些时候主线也更清晰。
Aqua 的定位还是一个 Script Language，所以我还是更希望保留异常系统的。&lt;/p&gt;
&lt;h3 id="finally"&gt;对 finally 和异常的看法&lt;/h3&gt;
&lt;p&gt;关于 finally 代码块的含义，一般被认为是“保证某段代码执行结束时一定会调用的代码”。
其作用一般是清洁工作，保证资源在任何情况下都被正常释放等。
但当 finally 代码块中包含流程跳转时——特别地，可能抛出异常时——其含义变得不甚符合直觉了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 在 finally 中可以使用 return 和 break, 也可以抛出异常。&lt;/p&gt;
&lt;p&gt;如果使用了 return, 进入 finally 前试图返回的值会被这里替换。&lt;/p&gt;
&lt;p&gt;如果进入 finally 前正在抛出异常，该异常抛出的行为会因为 finally 中的 return/break 而中断，也会被 finally 中抛出的异常所覆盖，这些通常不是想要的结果(Java 和 Ruby 也有相同的问题)。&lt;/p&gt;
&lt;p&gt;特殊地，Python 不允许在 finally 块中使用 continue, 称为是 CPython 的实现问题。
猜测大概是因为 CPython 中 continue 在字节码层面上被直接实现为 GOTO 的缘故(对应地，break 有单独的字节码，并且所需信息在 SETUP_LOOP 中已经存储)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Golang 中倾向使用错误返回值，但也可以使用 panic 和 recover 实现非局部跳转。
    Golang 中的 defer 从某些意义上部分近似于 finally.&lt;/p&gt;
&lt;p&gt;Golang 中的 defer 可以直接修改返回值。
defer 后跟着的是函数，因此不需要考虑 return/break/continue 等。&lt;/p&gt;
&lt;p&gt;Golang 总是保证所有 defer 执行完毕，就算是 defer 中产生 panic 也不例外——此时 golang 会选择中断这个 defer 去执行下一个 defer，并且将原先打算抛出的 panic 信息替换为此次 defer 发生 panic 的信息(尽管 golang 应该是记得之前 panic 的信息的，因为如果一直不 recover, 最后会打印所有 panic 的信息)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dlang 是比较特别的语言，它同时包括了 finally 和 defer(scope).&lt;/p&gt;
&lt;p&gt;Dlang 要求 finally 和 defer 中不能有 return/break/continue 等，也不允许使用 goto 再入，defer 中甚至要求不得 throw——尽管如此，它实际上不可能保证不在 defer 中抛出异常。&lt;/p&gt;
&lt;p&gt;Dlang 的 defer 中抛出异常和 golang 一样，要保证所有 defer 按 LIFO 的顺序执行完毕，但是 defer 中出现的异常会靠 Throwable.next 串起来，最后抛出的异常仍然是第一个发生的异常——尽管有忘记处理 .next 的风险。
Finally 中抛出的异常也会这样串在后面。&lt;/p&gt;
&lt;p&gt;(P.S.: Dlang 比较奇特的是 1/0 运行时直接浮点数例外，1.0/0.0 运行时是 inf，都不是异常……估计前者是类C，为了效率;后者是浮点数精度问题。)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上在有异常的系统中，有些地方是不应该出现异常的，对于 finally/defer/析构函数等，它们应该做的是收尾的操作，&lt;em&gt;本不应&lt;/em&gt;抛出异常。实际上，这种地方抛出异常应当视为&lt;em&gt;错误&lt;/em&gt;。而且如上面所说的，在抛出异常的过程中经过 finally 的时候如果发生异常，其行为可能是超出预期的。
同样的，捕获异常的 catch/except 等中实际上也是不应该发生异常的——我能想到的范围中，只有将异常重新包装并继续向上传播是符合预期的行为，在捕获异常的过程中意外发生的异常本身也应该是&lt;em&gt;错误&lt;/em&gt;。&lt;/p&gt;
&lt;p class="last"&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;script type="text/javascript"&gt;
(function(){
  $('h3').addClass('js-toggle-next dropdown');
  $('h3').each(function(i){
    $(this).nextUntil('h2,h3,p.last').wrapAll('&lt;div class="well"&gt;');
  });
  var is_show = false;
  $('#show_all').click(function(){
    if (is_show) {
      $('h3.js-toggle-next').next().hide();
      is_show = false;
      $('#show_all').text('展开所有项目');
    } else {
      $('.js-toggle-next').next().show();
      is_show = true;
      $('#show_all').text('闭合所有项目');
    }
  });
})();
&lt;/script&gt;</summary><category term="programming"></category><category term="aqua"></category></entry><entry><title>shaarli</title><link href="http://blog.skydark.info/programming/2012/08/21/shaarli/" rel="alternate"></link><published>2012-08-21T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2012-08-21:programming/2012/08/21/shaarli/</id><summary type="html">&lt;p&gt;上篇的最后推荐了一个叫&lt;a href="http://sebsauvage.net/wiki/doku.php?id=php:shaarli"&gt;shaarli&lt;/a&gt;的个人网址管理工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/misc/shaarli.jpg" alt="Screenshot for shaarli"&gt;&lt;/p&gt;
&lt;p&gt;优点就是 Simple &amp;amp; Fast, 找个能跑 php 的地方就成，支持 Tag, Picture Wall, RSS, 带 QRCode 的 Permalink, Private Link...&lt;/p&gt;
&lt;p&gt;在系主页上布置的时候遇到的一点问题，记录一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;需要有写权限。系里的主页大家都公用，彼此都能看到对方的家目录因此默认755, 部署的时候至少要把 data, tmp, cache 三个目录打开写权限，不然第一次登录的页面都看不到;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Shaarli 自带了一个书签，在 tools 里，放到书签栏可以快速保存。不过我这边一般都不显示书签栏……照着&lt;a href="https://addons.mozilla.org/zh-CN/developers/docs/how-to/getting-started"&gt;帮助&lt;/a&gt;做了个右键菜单扩展，不过工具栏按钮不知为何怎么也做不上……&lt;a href="http://blog.csdn.net/z6482/article/details/7433460"&gt;这个&lt;/a&gt;中文帮助看起来写的不错。自用所以直接把地址写死了就不放出来丢人了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Picture Wall 功能对 U2B, flickr 之类的国外站点支持不错，国内显然是无视的。为了方便收藏 B 站视频试图给 shaarli 添加 B 站缩略图支持。
B 站的 api 可以在&lt;a href="http://www.bilibili.tv/api.txt"&gt;http://www.bilibili.tv/api.txt&lt;/a&gt;看到，appkey 不用申请其实也能用。&lt;/p&gt;
&lt;p&gt;Shaarli 使用函数 &lt;code&gt;computeThumbnail&lt;/code&gt; 求缩略图地址，对 U2B 这类的站点可以直接从网址求出来缩略图地址；
对 flickr 这样要通过 api 得到缩略图地址的(作者在注释里还对此狠命吐槽了一番……)，就先返回 &lt;code&gt;index.php?do=genthumbnail&lt;/code&gt; 这样的地址再进行 Ajax 调用，当然这样可以把缩略图 cache 到 cache 目录中。&lt;/p&gt;
&lt;p&gt;本地测试OK，然后实际部署时发现系里的服务器没有连上外网，而且连 ipv6 都没有233……最后只好又重新布置到实验室的电脑上了……&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><category term="programming"></category><category term="php"></category></entry><entry><title>newLISP 是如何令我惊愕忘形的</title><link href="http://blog.skydark.info/programming/2012/06/28/newlisp/" rel="alternate"></link><published>2012-06-28T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2012-06-28:programming/2012/06/28/newlisp/</id><summary type="html">&lt;p&gt;偶然看到&lt;a href="http://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/"&gt;这篇文章&lt;/a&gt;， &lt;a rel="tooltip" title="不然一个英语爆烂的非 Lisper 怎么会翻译一篇 Lisp 文章呢"&gt;感到非常有意思&lt;/a&gt;，忍不住想翻译一下。&lt;/p&gt;
&lt;p&gt;原文标题是“How newLISP Took My Breath (And Syntax) Away”，非常漂亮的一个标题，但是不知道怎么翻译好，就随便编了一个句子上来了……= =&lt;/p&gt;
&lt;p&gt;newLISP 是一种奇特的 LISP 方言，有非常鲜明和有趣的特点，这篇文章的作者以亲身经历对这些特点做了一个简要的概述。&lt;/p&gt;
&lt;p&gt;另外必须强调的是，尽管我清楚我英文(和汉语)是如此之烂(从高二高三没上过课到大学没翻过书)，但是因为确实感到很有趣，我还是忍不住想编一下…… 所以，如果&lt;strong&gt;英文水平在高一以上，或者熟悉 Lisp，推荐直接看原文好了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然欢迎指正，如果这自High的私家地有人看的话……&lt;/p&gt;
&lt;p&gt;废话少说，&lt;strong&gt;&lt;em&gt;下面开始正文&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;div class="alert alert-danger"&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我不懂翻译，下面都是我瞎编的，现在我编不下去了……&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h2 id="newlisp-是如何令我惊愕忘形的"&gt;newLISP 是如何令我惊愕忘形的&lt;/h2&gt;
&lt;p&gt;作者：&lt;a href="http://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/"&gt;taoeffect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几年前，一个鲜为人知的名为 &lt;strong&gt;newLISP&lt;/strong&gt; 的语言彻底地改变了我对什么样的程序语言才是“好的”的理解。&lt;/p&gt;
&lt;h3 id="为何是-newlisp"&gt;为何是 newLISP?&lt;/h3&gt;
&lt;p&gt;在说其它话之前，我愿意提出一个我的一些熟悉 LISP 的读者们可能会立刻询问的问题： &lt;strong&gt;为何是 newLISP? 为何不是 Clojure, Scheme, 或者 Common LISP?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是，在评估这些 LISP 方言之后，我得出的结论是， &lt;em&gt;newLISP有几处重要的优势超过了其它 LISP&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在今天，不幸地是，每当有人在其它 LISP 的信徒们经常光顾的在线论坛上提及 newLISP 的时候，总是会爆发一场帮派战火。 一种特定方言的信徒(通常从没用过 newLISP)，会用污秽的话语吼叫， &lt;strong&gt;“newLISP 背弃了 LISP 取得的几乎所有优点”&lt;/strong&gt;，或者 &lt;strong&gt;“动态作用域是邪恶的！”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些情绪诞生的历史背景对那些观战者来说大多是未知的。 进而真相淹没于尘埃，讨论就此崩溃，混战因而散去，旁观者们继续回去啜饮他们的&lt;a rel="tooltip" title="Java是一种咖啡"&gt;Java&lt;/a&gt;，或者吃它们的&lt;a rel="tooltip" title="Python的原意是蟒蛇"&gt;Python&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我想值得庆幸的是，我对这门语言的介绍并没有从这些战斗中突然冒出来。 它在大多数部分上是基本没有偏见的。&lt;/p&gt;
&lt;h3 id="被称作-lisp-的东西"&gt;被称作 LISP 的东西&lt;/h3&gt;
&lt;p&gt;在就读于佛罗里达大学的时候，我选了一门有关人工智能的课程。 我们的教授不出所料地给班级介绍了一门名为 &lt;a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)"&gt;LISP&lt;/a&gt; 的程序语言。&lt;/p&gt;
&lt;p&gt;到那时为止，常见的那些不熟悉这门语言的人的传言和训诫构成了我对 LISP 的认识：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“喜欢它的人都是疯狂的痴迷者，认为自己超于常人！”&lt;/p&gt;
&lt;p&gt;“它主要用于人工智能方面的工作。”&lt;/p&gt;
&lt;p&gt;“没人把它用在实际用途中。”&lt;/p&gt;
&lt;p&gt;“它主要当作一门研究语言来使用。”&lt;/p&gt;
&lt;p&gt;“它代表‘&lt;a rel="tooltip" title="这句话的缩写恰好是 LISP"&gt;许多令人愤怒的愚蠢的括号&lt;/a&gt;’。哈哈！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你想的对。 我对于它到底是什么没有丝毫头绪，但令我激动的是，我最终被迫到不得不揭示它的地步。 毕竟，我的成绩依赖它。&lt;/p&gt;
&lt;p&gt;我的发现是， LISP 实际上不负于其狂信者赋予它的令人畏惧的盛名。 简单地接触一些 LISP 的基本概念和哲学立刻对我作为一个程序员的能力产生了积极的影响。&lt;/p&gt;
&lt;h3 id="语法程序员的头号敌人"&gt;语法：程序员的头号敌人&lt;/h3&gt;
&lt;p&gt;LISP &lt;a href="http://www.taoeffect.com/blog/wp-content/uploads/2009/12/LISP-in-a-nutshell2.gif"&gt;相对缺乏语法&lt;/a&gt;可能是其最深刻的见解，因为我立刻对此感到如释重负。 我意识到绝大多数程序错误的根源正是语法。 语法创造了我简直未意识到的下意识的负担： 它引发错误、缺陷，并且使得将我的想法转换为代码的工作变得困难。 尽管我有多年使用基于 C 的语言的经历，并且密切熟悉它们的语法， 我仍然意识到它依然是拖慢我和其他每个人的完全无必要的负担。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是像 Lisp 一样的语言的一个巨大优势： 它们仅有非常少的方式构造复合表达式，并且几乎没有语法结构…… 在我们忘记语言的语法细节(因为没有)后不久便在实际问题上取得了进展。&lt;/p&gt;
&lt;p&gt;——Abelson 和 Sussman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的关键不是语法的大小，而是你能拿它做什么。 LISP 能使用其列表、函数、符号等基本概念做的事情，在像 PHP、Python 和 Ruby 这样的语言中需要一层特殊的语法。 它能用更优雅的方式做其它语言能做的任何事情， 并且仍然有足够的技巧去挽起袖管完成在其它语言中根本&lt;em&gt;不可能&lt;/em&gt;做到的壮举。&lt;/p&gt;
&lt;h3 id="common-lisp-一系列不幸的错误"&gt;Common LISP: 一系列不幸的错误&lt;/h3&gt;
&lt;p&gt;尽管有所有这些令人激动的发现，我仍然有一种不安的感觉。&lt;/p&gt;
&lt;p&gt;Common LISP (CL) 是对我之前认识的一种巨大偏离， 但它充满了文物的恶臭； 更糟糕的是，它的语法简直没有很好地考虑过。 它所渴求的“禅”一样的完美消失了。 这是一种 Mac 用户都太熟悉了的感觉： &lt;strong&gt;有太多的按钮，而且其中大多数都没必要&lt;/strong&gt;。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://www.taoeffect.com/blog/wp-content/uploads/2010/01/CL-in-a-nutshell.gif" alt="CommonLisp&amp;#39;s syntax" /&gt;&lt;figcaption&gt;CommonLisp's syntax&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;对比 C++，这很美妙。话又说回来，与 C++ 相比，&lt;em&gt;大多数&lt;/em&gt;语言都显得值得称赞。 在尝过丢弃 C/C++/Java 的语法转到 CL 所提供的自由的味道后，我看不出来&lt;em&gt;为何&lt;/em&gt;所有这些语法都是必要的，而且事实上，大多不是的。&lt;/p&gt;
&lt;p&gt;每一小段引入语言的语法都增加了程序员的精神负担，无论他是否意识的到。 我并不打算花费精力学习 Common Lisp ——如果能找到更好的选择的话。&lt;/p&gt;
&lt;div class="well"&gt;
&lt;h4 id="你说的语法是什么意思"&gt;你说的“语法”是什么意思？&lt;/h4&gt;
&lt;p&gt;你可能反对我将函数&lt;code&gt;defvar&lt;/code&gt;,&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;eq&lt;/code&gt;,&lt;code&gt;eql&lt;/code&gt;等列入其中，因为它们是&lt;em&gt;函数&lt;/em&gt;。 我包括它们是因为它们构成了不能被 LISP 自身语法表达的低级功能。 换句话说，函数&lt;code&gt;=&lt;/code&gt;和&lt;code&gt;eq&lt;/code&gt;是必须在 LISP 语言的自身实现中定义的低级原语， 它们的含义和用法是不能从其它已有的 LISP 语法中演绎出来的。&lt;/p&gt;
&lt;p&gt;考虑 PHP 的&lt;code&gt;!=&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;，它们都是&lt;em&gt;运算符&lt;/em&gt;，并且用相同的方式使用，然而这并没有告诉你任何有关它们之间的区别是什么的事情。 没有办法从语言的现有语义演绎出它们的含义，因此它们分别表示一种必须习得的新的语法。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="我是怎样发现-newlisp-的"&gt;我是怎样发现 newLISP 的&lt;/h3&gt;
&lt;p&gt;教授向我们透露了我们的“主要课程项目”：我们要实现一个文字版本的&lt;a rel="tooltip" title="Chainshot"&gt;消同色&lt;/a&gt;游戏。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://www.taoeffect.com/blog/wp-content/uploads/2009/12/chainshot.png" alt="一个消同色游戏的实现" /&gt;&lt;figcaption&gt;一个消同色游戏的实现&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;消同色从一个充满带颜色的格子的网格开始。 你的目标是通过点击每个格子来清空盘面。 如果有与被点击的格子临近的同样颜色的格子，它们会一起消失。 这种效果会扩散到所有那些与它们相邻的格子上，如此下去。 接下来其它格子会掉落到消失的格子所留下的空档中。 如果有一整列消失了，那么所有该列右侧的格子都会左移来填补它。 在 OS X 上，有它的一个美妙和免费的实现叫做 &lt;a href="http://www.macupdate.com/info.php/id/24493/otis"&gt;Otis&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;在期中时我们要做一个能让人玩的版本，然后到期末时我们得写一个 AI 来玩这个游戏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“多说一句……”他说，“如果你用 LISP 完成它，你会得到 10% 的奖励。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而问题在于，大多数课程关注于 AI 的不同的算法和理论。 那些想得到这 10% 的奖励的人将不得不自学这门语言。&lt;/p&gt;
&lt;p&gt;多数学生选择放弃奖励而去使用一门他们已经熟悉的语言， 和大多数学生一样，我只有很少的时间， 所以我也偏向于那种情绪。 然而，我还是决定去 Google 搜索一下，看看我能不能发现一种更开胃的 Common LISP 的替代品。&lt;/p&gt;
&lt;p&gt;令我高兴的是我找到了一种似乎在所有选项上都符合的语言， 而且令人惊讶的是它竟然不是 &lt;a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)"&gt;Scheme&lt;/a&gt; (尽管那也是一门美妙的语言)。 像 Scheme 一样，这门语言极大地简化了 Common LISP 的语法， 但它同时又带有一个满载着用来完成现代化脚本任务的实用函数的标准库， 而且你运行它时所需要的所有东西就是单个轻巧的可执行文件！&lt;/p&gt;
&lt;h2 id="探索-newlisp"&gt;探索 newLISP&lt;/h2&gt;
&lt;p&gt;这是最终使我转为一个 &lt;a href="http://www.newlisp.org/"&gt;newLISP&lt;/a&gt; 爱好者的原因。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://www.taoeffect.com/blog/wp-content/uploads/2009/12/newlisp-logo-horizontal-240x100.png" alt="NewLispLogo" /&gt;&lt;figcaption&gt;NewLispLogo&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;我们有几个月的时间完成项目的第一部分， 在截止日期前的晚上，我还没有完成它的任何一个完整的&lt;em&gt;单个部分&lt;/em&gt;。 我在其它事情上花了一晚上，然后花了大概一小时那么些的时间去查看 newLISP 的网站并了解它。&lt;/p&gt;
&lt;p&gt;第二天，在我要提交我的可玩的完成版消同色的大约四个小时前，我在桌前坐下，戴上我的耳机，并着手在使用 newLISP 制作这款游戏的&lt;em&gt;同时&lt;/em&gt;学习它。&lt;/p&gt;
&lt;p&gt;我大约在 &lt;strong&gt;3 小时&lt;/strong&gt;内完成了，其中只有大约十分钟花在调试上。 我傻眼了。我发现了一种新东西，一门允许我迅速地写出(在多年与基于 C 的语言打交道之后)看似&lt;em&gt;恰好够用的几乎“无缺陷的代码”&lt;/em&gt;的语言。 这是一门我在短短数分钟内就接近&lt;em&gt;掌握&lt;/em&gt;的语言，而我在此之前从来没使用过它！ 在我学完 newLISP 而且用它写一个基于文本的游戏的时间里，我大概只够学完 Ruby 或 Python 的教程。&lt;/p&gt;
&lt;h3 id="newlisp-的力量"&gt;newLISP 的力量&lt;/h3&gt;
&lt;p&gt;我在这篇文章的开头声称newLISP有几处重要的优势超过了其它 LISP. 这些优势都可以总结为下面的话： &lt;strong&gt;如果你想要一门基于 Lisp 的脚本语言，选择 newLISP.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在深入到细节之前，让我先警告一下：&lt;/p&gt;
&lt;div class="well"&gt;
&lt;p&gt;&lt;strong&gt;newLISP &lt;em&gt;不&lt;/em&gt;是一门通用用途的程序语言。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;你不会用 JavaScript 去写一个 iPhone 应用(有人&lt;a href="http://www.nimblekit.com/"&gt;持不同的看法&lt;/a&gt;)，同样意义下， 你也不会用 newLISP 去写一个操作系统，或一个像 iTunes 一样的音乐播放器，或者一个像 Firefox 一样的网页浏览器。 对于这样的努力，我毫不犹豫地推荐 Clojure, Scheme, C, Objective-C 或者其它的语言——换句话说，那些适合于解决复杂、低层次问题，越快越好的语言。&lt;/p&gt;
&lt;p&gt;在 newLISP 的站点上最开头的话陈述道(强调部分是我自己添加的)：&lt;/p&gt;
&lt;div class="well"&gt;
&lt;p&gt;&lt;strong&gt;newLISP 是一门类 LISP 的，通用用途的&lt;em&gt;脚本&lt;/em&gt;语言。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在很久以前，计算机还很慢的时候，LISP 社区被那些使用 C 和汇编的同行们所无情的嘲笑，因为它那&lt;em&gt;太慢&lt;/em&gt;的罪过。 自那以后性能问题一直是 LISP 社区的痛处，我敢说，这点仍然有待于完全恢复。 其焦点转向编译，并以此向世界证明它一样可以很快。 结果，似乎很少有人注意到对解释型和脚本化的通用用途的 LISP 的需求。&lt;/p&gt;
&lt;p&gt;幸运的是，newLISP 似乎相当适合这种角色。 它是一个通用用途的解释型脚本语言。 我个人的理解是，因为它是如此的动态，使得它甚至不能被编译为字节码(尽管这并不意味着它不快)。&lt;/p&gt;
&lt;p&gt;离开这种见解，它的一些设计决策将没有意义。 为何选择 f表达式替代宏？为何使用动态作用域而非词法作用域？ 为何使用&lt;a rel="tooltip" title="One-Reference-Only" href="http://www.newlisp.org/MemoryManagement.html"&gt;唯一引用&lt;/a&gt;的内存管理方式，而不是垃圾收集？&lt;/p&gt;
&lt;h3 id="设计与语法"&gt;设计与语法&lt;/h3&gt;
&lt;p&gt;newLISP 包含在单个轻巧的 200+KB 的二进制文件中。 在我尝试过的所有 LISP 的派生中，它是最容易安装、部署和开发的。 不知为何这么轻巧的包中不仅囊括了完整的语言，还包括各种函数，如读写文件、解析文本、正则表达式、并行运行代码、网络等等。 我是班上唯一一个在期末项目中提交了完全并行求解每个格子的 AI (可伸缩到任意数量的核心)的人。 我实现了它的唯一理由是因为我可以毫不费力地做到。 newLISP 实现它简单到令人乏味，这是因为它拥有 &lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-19"&gt;actor&lt;/a&gt; 和 &lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-18"&gt;Cilk&lt;/a&gt; 的功能。&lt;/p&gt;
&lt;p&gt;newLISP 的语法简约而深思熟虑。 为了与 Common LISP 的语法卡片对比，我已保持大多数属性(例如字号)一致：&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://www.taoeffect.com/blog/wp-content/uploads/2009/12/newLISP-in-a-nutshell2.gif" alt="NewLisp&amp;#39;s syntax" /&gt;&lt;figcaption&gt;NewLisp's syntax&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;函数不需要任何 &lt;code&gt;&amp;amp;rest&lt;/code&gt;, &lt;code&gt;&amp;amp;optional&lt;/code&gt; 的标记。 简单地传进变量或反之，没有得到值的形参将置为 &lt;code&gt;nil&lt;/code&gt;，多余的部分可以通过函数 &lt;code&gt;(args)&lt;/code&gt; 或符号 &lt;code&gt;$args&lt;/code&gt; 获取到。&lt;/p&gt;
&lt;p&gt;函数像大多数其它东西那样对自己求值。 你不需要一个特殊的 &lt;code&gt;#’&lt;/code&gt; 语法来存取它们。 函数也是&lt;em&gt;真正的列表&lt;/em&gt;。 这意味着你可以在它们已经被定义好后取得它们的&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#source"&gt;源码&lt;/a&gt;，甚至&lt;em&gt;&lt;a href="http://kazimirmajorinc.blogspot.com/2009/04/crawler-tractor.html"&gt;在它们正在执行时修改它们&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id="f表达式与求值"&gt;f表达式与求值&lt;/h3&gt;
&lt;p&gt;作为宏的替代，newLISP 选择使用 &lt;a href="http://en.wikipedia.org/wiki/Fexpr"&gt;f表达式&lt;/a&gt;——根本不对其参数进行求值的函数(尽管有些令人懊恼的是，newLISP 称呼它们为宏)。 这项决定是有道理的，因为在一个解释型 LISP 中，几乎每件事情都在运行时发生， 在有些情况下 f表达式比宏执行的要快很多。 这也意味着 newLISP 的“宏”不需要特殊的反引号语法，使得它们更容易读写。&lt;/p&gt;
&lt;p&gt;你可能听说过在其它语言中反对使用 &lt;code&gt;eval&lt;/code&gt; 的训诫。 在 newLISP 中这是不适用的。 newLISP 的 &lt;a href="http://kazimirmajorinc.blogspot.com/2008/12/speed-of-newlisp-eval-test-v100.html"&gt;eval 比其它 LISP 都要快&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这导致了许多后果，其中一个是有时 newLISP 的 f表达式可以&lt;a href="http://kazimirmajorinc.blogspot.com/2009/04/on-macro-expansion-evaluation-and.html"&gt;比在其它 LISP 中编译后的宏还要快&lt;/a&gt;， 而这也意味着使用 &lt;code&gt;eval&lt;/code&gt; 不再是令人皱眉的事情，这开辟了各种编码的可能性。&lt;/p&gt;
&lt;h3 id="相等与内存管理"&gt;相等与内存管理&lt;/h3&gt;
&lt;p&gt;值得注意的是，只有一种相等算符——等号。 newLISP 能够逃脱是因为其称为&lt;a href="http://www.newlisp.org/MemoryManagement.html"&gt;唯一引用(ORO)&lt;/a&gt;的内存管理模型。&lt;/p&gt;
&lt;p&gt;简而言之，大多数东西都是&lt;em&gt;传值&lt;/em&gt;的，所以你最终不再需要那些荒谬的比较函数。 如果两个东西有相同的值，它们就是相等的——就是这样(除了 &lt;a href="http://www.taoeffect.com/blog/2009/12/introducing-objective-newlisp/"&gt;Objective newLISP&lt;/a&gt; 的情况)。&lt;/p&gt;
&lt;p&gt;这并不像听起来那样疯狂。 在内部， newLISP 通过引用在内建函数中传递数据，并且还做其它的优化。 你可以通过&lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-3"&gt;上下文和符号&lt;/a&gt;来使用引用传递数据，或者使用 &lt;a href="http://www.taoeffect.com/blog/2009/12/introducing-objective-newlisp/"&gt;Objective newLISP&lt;/a&gt;. newLISP 的 ORO 也意味着&lt;a rel="tooltip" title="newLISP’s ORO also means repeatable code execution times"&gt;可重复的代码执行次数&lt;/a&gt;； 你永远也不会经历“垃圾收集地狱”，因为根本没有垃圾收集器。&lt;/p&gt;
&lt;h3 id="动态作用域"&gt;动态作用域&lt;/h3&gt;
&lt;p&gt;newLISP 对&lt;a href="http://en.wikipedia.org/wiki/Scope_%28programming%29#Dynamic_scoping"&gt;动态作用域&lt;/a&gt;的使用经常被小题大作。 的确，动态作用域&lt;em&gt;可以是危险的！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在相同意义下，&lt;em&gt;指针和酒精也可以是危险的！&lt;/em&gt; 但这不意味着你永远不应该使用 C 编程或者在聚会上享受。 你应当检查 &lt;code&gt;NULL&lt;/code&gt;，不要酒后驾车，并且当心“自由变量”。&lt;/p&gt;
&lt;p&gt;记住，newLISP 是一门解释语言。 newLISP 的作者 Lutz Mueller 做了一个简单的成本/收益分析，然后选择了动态作用域，因为它比词法作用域更快，而且动态作用域的潜在陷阱很容易被避免。 比起这样做：&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode scheme"&gt;&lt;code class="sourceCode scheme"&gt;(&lt;span class="kw"&gt;define&lt;/span&gt;&lt;span class="fu"&gt; &lt;/span&gt;(my-unsafe-func)
    (println my-var)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替代为这样做：&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode scheme"&gt;&lt;code class="sourceCode scheme"&gt;(&lt;span class="kw"&gt;define&lt;/span&gt;&lt;span class="fu"&gt; &lt;/span&gt;(my-safe-func my-var)
    (println my-var)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个很小的用来改善性能的代价，并且通常情况下拥有动态作用域的确是相当方便的(特别是在与不再被忌讳的 &lt;code&gt;eval&lt;/code&gt; 组合的时候)。 如果你仍然需要词法作用域，newLISP 也&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#expand"&gt;照顾&lt;/a&gt;&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#letex"&gt;到了&lt;/a&gt;&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#contexts"&gt;你&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="并行处理"&gt;并行处理&lt;/h3&gt;
&lt;p&gt;newLISP 使用一种有趣的方式并行运行代码。 Clojure 使用&lt;a href="http://clojure.org/refs"&gt;高级方法来使用多线程和确保安全性&lt;/a&gt;， 而 newLISP 则简单地利用其小巧的体积来让操作系统完成所有该做的事情！&lt;/p&gt;
&lt;p&gt;没有线程。 通过 &lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-19"&gt;actor&lt;/a&gt; 和 &lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-18"&gt;spawn/sync&lt;/a&gt; 很容易写出安全的并发代码，因为 newLISP &lt;em&gt;简单地 &lt;a rel="tooltip" title="UNIX 中用 fork 来复制当前进程产生新进程，并用写时复制来减少其开销。不知道如何翻译，感觉直接叫原名大家更熟悉……"&gt;fork&lt;/a&gt; 它自己&lt;/em&gt;。 其谦逊的身材使得这项操作变的相当的低廉，并允许操作系统处理调度和内存保护。 试试 fork 一个 JVM…… :P&lt;/p&gt;
&lt;h3 id="优秀的文档和社区"&gt;优秀的文档和社区&lt;/h3&gt;
&lt;p&gt;newLISP 的文档是&lt;a href="http://www.newlisp.org/downloads/manual_frame.html"&gt;我曾见过的优秀文档中最好的范例之一&lt;/a&gt;，简直超越了我所意识到的所有其它 LISP 的文档。 你不需要掏钱买一本书学习它，因为它不需要书！ 包括参考文档在内的简短手册是你学习这门语言所需要的所有东西。 它的文档是我能够成功拖延我的期中考试的主要原因之一。&lt;/p&gt;
&lt;p&gt;如果我不得不挑一个词来描述 &lt;a href="http://newlispfanclub.alh.net/forum/index.php"&gt;newLISP 的社区&lt;/a&gt;，这个词可能会是&lt;strong&gt;“惬意”&lt;/strong&gt;(对 Common LISP而言，这个词可能是“粗暴”)。 每个人的问题都会被听取并且快速而友善地回答，不需要拘谨。 Lutz Mueller 往往会回答你的问题或者直接将你的建议采纳到语言中。 这是一个小社区，没错，但它也是敏捷的，并且能够快速地变化而不需要什么政策约束。&lt;/p&gt;
&lt;h3 id="其它优点"&gt;其它优点&lt;/h3&gt;
&lt;p&gt;还有&lt;strong&gt;其它许多优点&lt;/strong&gt;，我将不会详细地论述它们：&lt;/p&gt;
&lt;div class="well"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#eval_rules"&gt;两种逐字字符串的语法&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://newlispfanclub.alh.net/forum/viewtopic.php?f=16&amp;amp;t=2770&amp;amp;p=15571#p15571"&gt;REPL 中带 tab 补全的 Readline 支持&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#unicode_utf8"&gt;完整的 Unicode 支持，字符串为 UTF8&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-21"&gt;简单强大的分布式计算&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-22"&gt;内置的 web 服务器&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#indexing"&gt;数组、列表和字符串的隐式索引与切片&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/downloads/newlisp_manual.html#loading_contexts"&gt;简单的状态存储与读取&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-23"&gt;简单的 C 接口&lt;/a&gt;(意味着你绝不会错过高速的库)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="结论-相关链接"&gt;结论 + 相关链接&lt;/h2&gt;
&lt;p&gt;newLISP 是一块货真价实的璞玉，尽管它缺乏炒作，但仍然美丽动人。&lt;/p&gt;
&lt;p&gt;如果你觉得这篇文章很有趣，你可能会觉得下面这些链接值得一看：&lt;/p&gt;
&lt;div class="well"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.com/"&gt;newLISP 的主页&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.rundragonfly.com/"&gt;Dragonfly——一个 newLISP 网页框架&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://kazimirmajorinc.blogspot.com/"&gt;Kazimir Majorinc 的博客&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://unbalanced-parentheses.nfshost.com/"&gt;Cormullion 的博客&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.newlisp.org/index.cgi?Code_Contributions"&gt;更大的一张 newLISP 相关链接的清单&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Twitter: @&lt;a href="http://twitter.com/newlisp"&gt;newlisp&lt;/a&gt;, @&lt;a href="http://twitter.com/taoeffect"&gt;taoeffect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="lisp"></category><category term="programming"></category></entry><entry><title>为什么 Lisp 经久不衰</title><link href="http://blog.skydark.info/programming/2012/06/15/why-lisp/" rel="alternate"></link><published>2012-06-15T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2012-06-15:programming/2012/06/15/why-lisp/</id><summary type="html">&lt;div markdown="1" class="alert alert-danger"&gt;
&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt;

你将看到的是毫无价值的胡言乱语，现在按 Ctrl-W 还来得及！&lt;/div&gt;&lt;hr&gt;
&lt;div class="alert alert-warning"&gt;
我警告过你了。&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;div id='toc-here'&gt;&lt;/div&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实一开始想拟的题目是“为何程序员都应该了解 Lisp”，然后仔细考虑了一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我不是程序员。实际上，我连码农都不是。更准确地，我没记得自己写过啥实际可用的东西。我唯一算能用的语言是 python.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我不了解 Lisp. 大三下半年听裘宗燕教授讲过一学期的 SICP，虽然&lt;a rel="tooltip" title="大学的考试大家都懂的"&gt;成绩倒说的过去&lt;/a&gt;，但实际上确实很多地方啪啪啪的就过去了，而且习题做的极少，我是很怀疑自己还记得多少真谛的。而且 SICP 是&lt;a rel="tooltip" title="虽然现在改 python 了"&gt;以 Scheme 为工具&lt;/a&gt;，以讲程序设计思想为主，并且&lt;a rel="tooltip" title="如果不是这样，就更说明我没仔细看书了"&gt;刻意避开了宏&lt;/a&gt;。除此之外，我对 Lisp 的理解基本都是因为兴趣无意中看到的各种文章。所以事实上，我的确是不了解 Lisp 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我甚至并没有打算继续深入 Lisp. 我认为 Lisp 是必须了解的程序语言之一，但我不认为必须要学会 Lisp，尽管如果我心血来潮可能会试着读一下 On Lisp. 我是说，心血来潮的话。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以以自己的实力来说，写这样一篇文章显然是在胡说八道；
而胡说八道放在公开的地方(虽然这里我不以为算太公开就是了……)等于立活靶子。
不过我想，给将来的自己留点反思和笑料总是好的。
上面说这么多废话的目的就是强调，这篇文章是为了给自己吐槽的。
所以总之，别当真。&lt;/p&gt;
&lt;p&gt;附：下面主要使用 Scheme.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;历史悠久的 Lisp&lt;/h2&gt;
&lt;p&gt;1958年诞生的 Lisp 是至今仍被人们广泛使用的高级语言中资历第二老的前辈(第一是1957年诞生的 Fortran)。
它的设计者，今年刚逝世的人工智能之父 John McCarthy，最初是在一篇谈论计算理论的论文中设计了 Lisp，并仅仅将它当作一种计算模型.
出乎 J. McCarthy 的意料，他的学生意识到这种理论模型完全可以实现为一个真正的程序语言，并真正实现了 Lisp 的编译器。&lt;/p&gt;
&lt;p&gt;Lisp 诞生的时代仍然是过程式语言的天下，在这种情况下横空而出的 Lisp 显得格外不可思议。
超前许多的 Lisp 在近代对编程语言的影响愈发深远——if-then-else、递归、动态类型、垃圾收集、一类函数、惰性求值、闭包……
实际上，很多优秀的近代语言都在追求用更让程序员习惯的语法来实现 Lisp 最常用的功能。
最具有代表性的例子大概是 Ruby，Ruby 是如此的借鉴和接近 Lisp，以至于可以将 Ruby 视为一种包装了优美语法糖的裁剪过的 Lisp 方言——&lt;a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642"&gt;MatzLisp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;但实话实说，Lisp 的思想虽然与当时的高级语言如此格格不入，其实也并不是一件特别值得惊奇的事情——因为 Lisp 一开始就不是为具体的一台机器设计的。
&lt;em&gt;Lisp 并不是程序语言，而是数学模型。&lt;/em&gt;
而当时的其他程序语言并不是如此，它们是基于机器模型设计的。
“程序语言是表达人的思想的，而不是表达机器的操作的”这样的想法，在当时硬件紧缺的时代并没有得到重视。
J. McCarthy 一开始就超脱机器思考问题，是 Lisp 超前于同时代其他程序语言的关键。&lt;/p&gt;
&lt;p&gt;Lisp 的背后是数学，是递归论和 lambda 演算。
一门程序语言能保持50余年的兴旺实属不易，而这样的事情对于数学来说反而并不奇怪。
J. McCarthy 是在深刻理解&lt;em&gt;计算&lt;/em&gt;的本质后设计的 Lisp 语言，它经久不衰是必然的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;简单优雅的 Lisp&lt;/h2&gt;
&lt;p&gt;假如评选世界上形式最简单易学的程序语言的话，Lisp 应该能排到前列——如果不是最前面的话。&lt;/p&gt;
&lt;p&gt;事实上，直到写这篇胡言乱语之时，我才意识到 Lisp 是我了解的第一门计算机语言。&lt;/p&gt;
&lt;p&gt;我小学五年级的时候曾经买过一本(实际上是上下两册)名为《数学游戏》的书，它是《科学美国人》杂志上有关数学部分的文章的集锦。
在那本书上有很多关于计算机的内容，其中有连续若干篇(大概3篇，记不清了)文章介绍了 Lisp 语言，顺便示范了怎样求解阶乘和汉诺塔。
那时连计算机什么样子都没见过的我不仅看的津津有味，而且还真的看懂了。
考虑到我一向愚笨，这大概能说明 Lisp 有多简练。&lt;/p&gt;
&lt;p&gt;但为什么我一直没有意识到自己了解的第一门语言是 Lisp 而不是 Basic 或 Foxbase 呢？
一个很好的理由是：那时对数学最感兴趣的我，根本没有把这门语言视为计算机语言，而确实地如那本书的标题所言，将其视为了一种“数学游戏”。
数学追求的是简单优雅的至美(“我的工作总是努力将真与美统一起来；但是，如果只能选择其中之一，那么我选择美。”——H. Weyl)，对计算机毫无背景的我能从 Lisp 上嗅到这种味道。&lt;/p&gt;
&lt;p&gt;Lisp 使用 S-表达式来存储代码和数据。
不严格地说，S-表达式就是符号或者符号/S-表达式的列表(用括号包起来并用空格分开每个元素)罢了。基本上只要见过 Lisp 程序的人都能读——这里是说能读出层次，而不是读出含义。&lt;/p&gt;
&lt;p&gt;而在 S-表达式之上，我们只需要定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;atom, eq: 对原子符号的判断;&lt;/li&gt;
&lt;li&gt;car, cdr, cons: 对 S-表达式的操作;&lt;/li&gt;
&lt;li&gt;quote: 对数据的标记;&lt;/li&gt;
&lt;li&gt;cond: 条件判断;&lt;/li&gt;
&lt;li&gt;lambda, label: 对函数的构建和标记。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就能实现一个最基本的 Lisp 解释器了。
SICP 中就用 Scheme 实现了一个 Scheme 解释器。
实际上，在很多近代高级语言中，实现一个最最基本的 Lisp 解释器都不必花太多精力。&lt;/p&gt;
&lt;p&gt;然而，设计简单并不意味着能力弱。
我们知道，即使是一个只能做加一减一和条件跳转的计算系统也可以是图灵完备的。
Lisp 不仅是图灵完备的，而且还能很容易的实现自己。
而对比图灵机模型，实现通用图灵机却相当艰辛。
那是因为通用图灵机将图灵机视为数字，然后大量工作都在对这个数字做 parse；
而 Lisp 告诉我们，只要代码和数据都使用同一个模型同一套处理方法，做这些事情易如反掌。
Lisp 的简单优雅由此可见一斑。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;没有语法的 Lisp&lt;/h2&gt;
&lt;p&gt;见过的对 Lisp 的抱怨中最常见的就是“Lisp 的语法咋这么别扭呢”、“那堆括号不会觉得密集恐惧症么”等等。
但实际上，我们通常认为 &lt;em&gt;Lisp 是弱语法的&lt;/em&gt;，或者可以更通俗地直接当作没有语法的。&lt;/p&gt;
&lt;p&gt;关于 Lisp “语法”的意见，一方面是关于 S-表达式的括号的意见，一方面是关于 S-表达式的前缀表示法的意见——简单地说，都是关于 S-表达式的意见。&lt;/p&gt;
&lt;p&gt;但是事实上，S-表达式与其说是 Lisp 程序的&lt;em&gt;语法&lt;/em&gt;，不如说是 Lisp 程序的&lt;em&gt;存储格式&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;我们对比一下，
大多数程序语言使用纯文本保存源代码，
而来自数学的 Lisp 本来就使用 S-表达式 表示源代码，只是我们不得不再次将其转换为纯文本进行读写罢了。
J. McCarthy 一开始关心的就是计算本身，设计的本来就是一种抽象模型，根本就没有考虑过 parse 的事情。
就像 RDF，它本来也只是一个关系模型而已，只是恰好选择了用 XML 表示而已。
它完全可以用其他方式表示，只是可读性的差别罢了。
Lisp 也是类似的。&lt;/p&gt;
&lt;p&gt;事实上，Lisp 和 XML 之间有很清晰的关系。
&lt;a href="http://www.defmacro.org/ramblings/lisp.html"&gt;这篇&lt;/a&gt;介绍 Lisp 的文章(很容易找到中文版)一开始就从 XML 入手，然后告诉大家 XML 和 S-表达式本质上是很接近的。
纯文本格式通常描述平坦结构，基于纯文本的 XML 和 S-表达式表达的则是一种层次结构。
只是 XML 更侧重于数据，而 S-表达式既可能是数据，也可能是代码——考虑到语法总是用来表达语义的，而单纯的一个 S-表达式你根本无从判断它是代码还是数据，所以将 S-表达式视为存储格式而非语法是恰当的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;现在站在 S-表达式的层面上来看 Lisp 的语法，那么 Lisp 的语法只剩下前面构造 Lisp 使用的几个关键词(各种方言有自己的扩展所以还有更多的一些词)。
但是通过 Lisp 的宏，你甚至可以重定义其中的一些关键词。
所以 Lisp 的语法是非常弱的。
如果经常在宏上工作，你甚至意识不到 Lisp 语法的存在。&lt;/p&gt;
&lt;p&gt;S-表达式实际上相当于一棵被解析过的语法树。
更进一步，我们考虑任意一种编译语言(解释语言等其实也是类似的，这里为了方便而已)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;S-表达式可以用来表示&lt;em&gt;任何&lt;/em&gt;语言的语法树；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个编译器(的后端)将代码树翻译为机器代码，这个过程是可计算的——显然，否则这个编译器就无法实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个翻译过程可以用 Lisp 实现，因为 Lisp 是图灵完备的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这意味着：你可以将任何语言的语法树不加修改的直接传递给 Lisp，而 Lisp 自然的视之为数据进行处理，翻译为 Lisp 代码执行。
更进一步的：&lt;/p&gt;
&lt;p&gt;4.这个翻译过程可以用 Lisp 的宏实现。&lt;/p&gt;
&lt;p&gt;这就意味着，你甚至不需要将这棵语法树当作数据处理，&lt;em&gt;直接当作代码执行&lt;/em&gt;都是可行的。
所以说，Lisp &lt;em&gt;没有语法&lt;/em&gt;，它天然是构建 DSL 的终极武器。&lt;/p&gt;
&lt;p&gt;对于其他语言来讲，构建元语言的步骤也是类似的。
我们拿以元编程能力为豪的 Ruby 为例(再次提醒，Ruby 继承了 80% 的 Lisp)。
Ruby 可以使用&lt;em&gt;自己的语法&lt;/em&gt;构建一套外表非常漂亮的 DSL.
但是问题就在于，你&lt;em&gt;只能&lt;/em&gt;使用 Ruby 的语法——无论它看起来多么赏心悦目，它还是 Ruby 的那套语法。
关键点是，只能使用固定的语法实际上也就意味着只能表达固定语法所能表达的语义。&lt;/p&gt;
&lt;p&gt;比如说在没有 Until 的 Python 中，如果需要添加能表达 Until 语义的关键词，就不得不修改 Python 的语法。
在 Ruby 中，如果我们假设 Ruby 删掉了 Until，那么可以通过 Block 显得优雅的实现它。它是基于 Block 的特性实现的。
这也就意味着 Block 的局限也会限制这种语法的表达。我们再看另一个例子。&lt;/p&gt;
&lt;p&gt;我们试着构造一个 or 函数，它的含义正如其名。
我们希望 &lt;code&gt;or(False, True, 1 + 0) = True&lt;/code&gt;.
这很容易，大多数高级语言都可以完成。&lt;/p&gt;
&lt;p&gt;好，现在我们希望这个 or 具有短路求值的功效，
即 &lt;code&gt;or(False, True, 1/0) = True&lt;/code&gt; 而不是出错。
这意味着我们要对每个参数进行惰性求值。
如果语言没有内置惰性求值，我们就不得不自己实现它，但这往往会破坏代码的外观。&lt;/p&gt;
&lt;p&gt;简单起见，拿 Ruby 为例，在 Ruby 中我能想到的最好的实现方法是：&lt;/p&gt;
&lt;p&gt;提醒：我的 Ruby 和 Scheme 水平堪忧。
{:.alert .alert-warning}&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己实现一个惰性求值函数 lazy，它接受一个 Block 并将其保存下来(P.S.: Scheme 的标准文档中提供了一个 lazy 的宏实现，也可以与这里做对比，但我想没这个例子这么突出，因为 Block 确实是一个很漂亮的语法形式);&lt;/li&gt;
&lt;li&gt;对 or 的每个参数用 lazy 和 Block 包装起来——为什么不能直接把每个参数用 Block 包装起来然后 or 保存下来惰性求值？因为 Ruby 只能显示地接受单个 Block。通过保存 Block 为 Proc 可以存储多个 Block——而这正是 lazy 函数做的事情。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以用 Ruby 实现的话，最终短路求值的 or 将被写成(暂且不提 lazy 的实现)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;or_new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lazy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kp"&gt;false&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;lazy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;lazy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Ruby 中 or 是关键字且不能更改，这里改叫 or_new)&lt;/p&gt;
&lt;p&gt;很明显的，Ruby 的语法限制了表达能力。&lt;/p&gt;
&lt;p&gt;来看一下无语法的 Lisp. 我们只需要把上面那句话的翻译成 S-表达式表示的语法树(scheme 中已经有 or 了，所以这里叫做 or-new 避免混淆，但你仍然可以直接定义成 or)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or-new&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后想想怎么定义 or 宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax &lt;/span&gt;&lt;span class="nv"&gt;or-new&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax-rules &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;or-new&lt;/span&gt; &lt;span class="nv"&gt;exp1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;exp1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;or-new&lt;/span&gt; &lt;span class="nv"&gt;exp1&lt;/span&gt; &lt;span class="nv"&gt;exp2&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;exp1&lt;/span&gt;
          &lt;span class="no"&gt;#t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or-new&lt;/span&gt; &lt;span class="nv"&gt;exp2&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It works!&lt;/p&gt;
&lt;p&gt;更进一步，你甚至可以用 Lisp 写出这样的东西然后拿宏去解析它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sql&lt;/span&gt; &lt;span class="nv"&gt;select&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nv"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;some-table&lt;/span&gt;
            &lt;span class="nv"&gt;where&lt;/span&gt; &lt;span class="nv"&gt;column1&lt;/span&gt; &lt;span class="nv"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;and &lt;/span&gt;&lt;span class="nv"&gt;column2&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some%string%&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者甚至用 &lt;code&gt;sqrt(x) = 3&lt;/code&gt; 来表示 &lt;code&gt;x&lt;/code&gt; 的值为 9，这在其他语言中简直&lt;a href="http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html"&gt;匪夷所思&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;记住：Lisp 中没有任何语法限制框住你，因为 Lisp 只有一种语法——那就是没有语法！&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;擅长抽象的 Lisp&lt;/h2&gt;
&lt;p&gt;一个语言(不仅是程序语言，也包括自然语言)的表达能力体现在很多方面。
而表达能力中最重要的一点是&lt;em&gt;抽象能力&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;所谓语言的抽象能力，就是表示从一类问题和模式中挖掘出的本质的能力。
一方面，要有能表示的能力；另一方面，要表示的足够清晰简洁。
汇编语言的抽象能力是很低的，因为它下放的层次太低，过于接近机器而远离人类的思维。
假如我们一直在使用汇编语言来编写程序，难以想象现在这些面向对象、异常处理等思想会从中诞生，因为我们大多数时间都会在细节的泥沼中挣扎。
一个人使用的程序语言的抽象能力，实际上影响了他思考问题的方式。&lt;/p&gt;
&lt;p&gt;Lisp 中一切都是 S-表达式，因此一切都是平等的，无论是原子、列表、函数、过程，甚至宏。&lt;/p&gt;
&lt;p&gt;在 Lisp 中，函数与一般的列表没有什么区别，它可以被当作函数的参数，可以被当作返回值，可以赋值为变量，可以存储到数据结构中，这被称作是“一类函数”。
这在一些语言中难以实现也难以理解。
在 C 中，一类函数实际上是函数指针，但是 C 中代码与数据界线分明，很多人理解函数指针、理解回调的时候都会感到这是一个很大的槛。
而在 Lisp 中这却自然到不能再自然——函数也是个 S-表达式，与一般的表达式没什么区别，仅此而已。&lt;/p&gt;
&lt;p&gt;Lisp 的闭包也是自然的，它实际上是一个来自数学和逻辑的概念。
拿一个 Python 程序为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们执行 &lt;code&gt;h = f(1)&lt;/code&gt;，它返回一个函数，这个函数是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到问题了吗？这里 &lt;code&gt;x&lt;/code&gt; 取什么值根本不知道，这种变元即为自由变元，这样的函数返回了也无法求值。&lt;/p&gt;
&lt;p&gt;所以我们把“ &lt;code&gt;x&lt;/code&gt; 的值是 1 ”这件事情也悄悄地绑在返回的函数上，把自由变元封闭成约束变元，这个函数将来就可以正常求值了，这种把自由变元也闭合起来的函数就是(静态作用域的)闭包。&lt;/p&gt;
&lt;p&gt;当然 Python 的闭包实际上与真正的闭包还有一些差距，与它的对象可变性有关。
Anyway, 这种时候还是让 Java 程序员们对闭包纠结和争执去吧。
如果语言没有这种抽象能力，使用语言的时候自然也不会用这种方式思考，自然也不会觉得这种能力有用了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了抽象函数之外，我们还可以抽象过程。
在 Lisp 中常被称作 call/cc，即 call-with-current-continuation, scheme 要求实现的功能之一，在部分没有内置支持的 Lisp 中可以直接用宏实现出来。&lt;/p&gt;
&lt;p&gt;call/cc 将当前的执行过程抽象为一个符号，然后传给一个函数计算。
简单地说，程序执行过程实际上就是当前位于代码中的哪个位置，加上当前的环境状况而以。而执行程序的时候，就是位置的改变和环境的改变。
如果我们允许函数自己保存或修改这些参数，决定下一步执行哪里，就可以随意控制程序的执行过程了。
这就意味着，虽然在 Lisp 中没有循环、没有异常处理、没有 break、没有 return……等等各种控制结构，这都没有关系，我们都可以用 call/cc 来抽象并实现它。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;宏实际上就是一种转换固定代码模式的能力，它能抽象出程序的组织方式，并且用最简单和自然的方式表达出来。
对应到数学中，这实际上就是我们在证明定理时做的符号变换和指代。&lt;/p&gt;
&lt;p&gt;程序的组织方式中最经典的例子是设计模式。
有些设计模式是好的被经验所验证的思考问题的方式，而更多的设计模式实际上是程序语言抽象能力缺陷的体现——一种代码组合经常以类似的方式出现，程序语言却没有能力把它抽象成更简单的形式，不得不 Repeat Yourself，进而就变成了设计模式。&lt;/p&gt;
&lt;p&gt;当然，宏是一个大杀器。
所谓能力越大责任越大，使用宏的第一原则就是&lt;em&gt;不要使用它&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;当然不是说 Lisp 的宏本身有很大的危险。
和 C 的宏不同，Lisp 的宏非常安全，一方面它直接基于语法树，而不是 C 这样经过一次 parse，所以不会像 C 那样因为缺少括号等问题导致混淆；另一方面，卫生宏的存在也使得宏替换的安全性有理论保证。
在很多语言中，代码动态转换是非常危险的，只有 Lisp 除外。&lt;/p&gt;
&lt;p&gt;宏就像一把屠龙刀，很多时候能用一类函数解决的问题就不应该使用宏，而这种情况往往占了大多数。
但是不要忘了，程序设计中的龙可不少——龙书的封面就是例子。
如果只知道一类函数而不知道宏，就容易在面对龙的时候缺乏灵活性。
就好像面对火龙只知道用剑，却没有注意到它的头顶有一块摇摇欲坠的巨石一样。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更多的现代程序语言在更适合纯文本的表述与抽象能力之间进行折衷，即追求形式美与表达力的结合。&lt;/p&gt;
&lt;p&gt;形式美是多种多样的，
追求精炼的喜欢 Perl，
追求清晰的喜欢 Python，
追求灵动的喜欢 Ruby……
这些都是程序语言的“形”，它们哪种更美因人而异，并没有哪个具有真正意义上的绝对优势。&lt;/p&gt;
&lt;p&gt;而它们的表达能力却都逐渐向 Lisp 靠拢。
例如 Ruby 的 Block，实际上是对一种最常见的介于一类函数和宏模式之间的抽象——这种宏不对传进的代码做处理，与一般的闭包差距也只有很小的一点(主要原因是 Block 中默认不是 Local Variable，以及同时打包了部分控制流)。
松本行弘也在他的书中说道，Ruby 引入块就是为了高阶函数，而高阶函数中大部分是只有一个函数参数的，于是他便将这种最常用的形式用更美观的方式包装成了 Block.
只是受限于其纯文本的语法，不得不受到了限制，一方面是数量限制，另一方面是一定要显示地标记为块结构，而不能像宏那样不留痕迹，同样还有运行开销的问题。&lt;/p&gt;
&lt;p&gt;当一门语言的设计逐渐不以机器为主导而以人的思维为指导时，
这门语言就愈发接近计算的本质——而 Lisp 本来就是以此为指导思想设计的语言。&lt;/p&gt;
&lt;p&gt;Lisp 彻底超脱了 plain text，通过 S-表达式与宏来实现了二者的统一。
Lisp 通过丢弃程序语言的“形”，来真正展现程序语言的“神”。
站在抽象表达能力顶端的 Lisp 对于现代程序语言来说是一座早就确立的灯塔，自然不会轻易衰落。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;无处不在的 Lisp&lt;/h2&gt;
&lt;p&gt;一种程序语言的兴起往往与很多语言之外的因素相关，比如它首先依托的项目，它得到的经济支持，早期关注者的影响力，杀手级的应用，是否恰好顺应了当时机器的发展与程序员的思维水平，库的丰富程度等等。
然而 Lisp 与其它语言不同，它比起一门程序语言，更应该视为一种数学模型和一种思想。
Lisp 和它的思想不会消亡，只会更加广泛地融入到各种现代程序语言中。
试着去体会 Lisp 的精髓，对程序与计算的思考会更加深刻。&lt;/p&gt;
</summary><category term="programming"></category><category term="ruby"></category><category term="lisp"></category></entry><entry><title>Play with Jekyll</title><link href="http://blog.skydark.info/programming/2012/03/23/play-with-jekyll/" rel="alternate"></link><published>2012-03-23T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2012-03-23:programming/2012/03/23/play-with-jekyll/</id><summary type="html">&lt;p&gt;&lt;div id="toc-here"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://appblog.skydark.info"&gt;原先的blog&lt;/a&gt;是使用&lt;a href="http://micolog.xuming.net"&gt;micolog&lt;/a&gt;搭建在 GAE 上的。
但是随着 GAE 免费配额方案的改变，加上徐明对 micolog 的维护逐渐停滞，感觉有转移出去的必要了。&lt;/p&gt;
&lt;p&gt;感谢 V2EXer &lt;a href="http://www.yangzhiping.com"&gt;阳志平&lt;/a&gt;的博文：&lt;a href="http://www.yangzhiping.com/tech/wordpress-to-jekyll.html"&gt;告别wordpress，拥抱jekyll&lt;/a&gt;，
和&lt;a href="http://www.yangzhiping.com/tech/writing-space.html"&gt;理想的写作环境：git+github+markdown+jekyll&lt;/a&gt;，
最终促使我做出了使用 Jekyll 将 blog 迁移到 github 上的决定。&lt;/p&gt;
&lt;p&gt;Jekyll 有很多吸引我的地方，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于 git，天然的版本控制能力;&lt;/li&gt;
&lt;li&gt;基于 markdown，干净利落，方便处理，配合 git，写文章只需要 vim 足矣;&lt;/li&gt;
&lt;li&gt;直接可放在 github 上，无需担心空间和维护问题;&lt;/li&gt;
&lt;li&gt;轻量纯静态，方便迁移，无需担心安全问题;&lt;/li&gt;
&lt;li&gt;可定制性强，只要是静态的就可以。如果在 github 以外的空间存放生成好的站点，添加后端代码也是可行的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终迁移是在妇女节进行的(……)。总的来说很顺利。&lt;/p&gt;
&lt;p&gt;P.S.: 阳志平是位心理学工作者，也是位 Ruby 爱好者。他的文章写的干净利落，思路清晰，思考深刻。我很欣赏他的文章。&lt;/p&gt;
&lt;h2&gt;搭建&lt;/h2&gt;
&lt;p&gt;应该强调的是，这篇文章只是想留下做私人笔记，不能算是教程。
如果需要教程，可以参考阳志平先生的那几篇文章。&lt;/p&gt;
&lt;p&gt;那么开始，首先当然需要一个 github 帐号，自然还有 git.&lt;/p&gt;
&lt;h3&gt;git&lt;/h3&gt;
&lt;p&gt;git 是一个&lt;em&gt;版本控制软件&lt;/em&gt;，作用是记录你对一个项目的所有&lt;em&gt;修改历史&lt;/em&gt;。
我以前也只是将它用来备份自己写的一些垃圾而已，所以并不算熟悉。
关于学习 git，个人推荐&lt;a href="http://progit.org/book/zh/"&gt;这本书&lt;/a&gt;。
当然，更关键的还是&lt;strong&gt;先用起来&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;github&lt;/h3&gt;
&lt;p&gt;有关&lt;a href="http://github.com"&gt;github&lt;/a&gt;，
阳志平先生的&lt;a href="http://www.yangzhiping.com/tech/github.html"&gt;这篇博文&lt;/a&gt;让我觉得已经不必介绍的更多了。&lt;/p&gt;
&lt;p&gt;关于 github 的影响力，简单地看看本文里多少软件的链接出自 github 就知道了，其中有些还是有 github 但我贴了其他地址的。&lt;/p&gt;
&lt;p&gt;关于 github 的配置如果还有不明白的地方，看它官网的 help 足矣。&lt;/p&gt;
&lt;h3&gt;jekyll bootstrap&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://jekyllbootstrap.com/"&gt;Jekyll Bootstrap&lt;/a&gt;
是一个对生成&lt;em&gt;静态 blog 类站点&lt;/em&gt;的工具 Jekyll 的一个包装。
对于快速上手而言，它能减少很多麻烦。
如果只是想快速在 github 上搭建一个 blog，照着它主页说的走一遍非常容易。&lt;br&gt;
另外就像它的名字一样， Jekyll Bootstrap 默认是基于&lt;a href="http://twitter.github.com/bootstrap/"&gt;bootstrap&lt;/a&gt;的主题，twitter一贯的清新风格。&lt;/p&gt;
&lt;h3&gt;ruby&lt;/h3&gt;
&lt;p&gt;当然，为了在本地生成和预览结果，需要安装 jekyll，也就是说需要首先安装 ruby.&lt;/p&gt;
&lt;p&gt;Ruby 据说在 Mac 下工作最好，Linux 也不错，Windows 不敢恭维。&lt;/p&gt;
&lt;p&gt;总而言之，还是推荐使用 &lt;a href="http://beginrescueend.com/"&gt;rvm&lt;/a&gt; 安装 ruby.&lt;/p&gt;
&lt;p&gt;淘宝提供了 rubygems 的&lt;a href="http://ruby.taobao.org/"&gt;镜像源&lt;/a&gt;，
可有效加速 gem 的安装，强力推荐。&lt;/p&gt;
&lt;h3&gt;jekyll&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;Jekyll is a simple, blog aware, static site generator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/mojombo/jekyll/wiki"&gt;Jekyll&lt;/a&gt;
由两个部分协同工作，
一边是将标记语言(Textile, Markdown)转换为 html 语言的转换器，
另一边是模板引擎 &lt;a href="https://github.com/shopify/liquid/wiki"&gt;Liquid&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;本地安装 Jekyll 只需要运行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;Jekyll Bootstrap 的首页已经将主要需要配置的部分说明的很清楚了，像评论申请一个 &lt;a href="http://disqus.com"&gt;disqus&lt;/a&gt; 帐号就行。
这里说一些可能需要额外提醒的部分。&lt;/p&gt;
&lt;h3&gt;github 支持&lt;/h3&gt;
&lt;p&gt;如果需要将页面放在 github 上，那么需要注意 github 上：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持自定义插件，因此需要特殊处理的页面最好自己写进 Rakefile 里;&lt;/li&gt;
&lt;li&gt;有些微妙的地方与本地不同。在我这里，如果使用中文的 markdown 文件名，最后生成的站点路径将找不到，而 github 上可以; 如果在 liquid 中使用 split filter，本地可以正常应用，而 github 上不可以。也可能是因为两边使用的 jekyll 版本有别？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;markdown 引擎&lt;/h3&gt;
&lt;p&gt;Jekyll 可以使用的 markdown 引擎至少有
&lt;a href="http://maruku.rubyforge.org/index.html"&gt;maruku&lt;/a&gt;,
&lt;a href="https://github.com/rtomayko/rdiscount"&gt;rdiscount&lt;/a&gt;,
&lt;a href="http://kramdown.rubyforge.org"&gt;kramdown&lt;/a&gt;.
我列举的顺序就是我尝试的顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maruku 是默认的 markdown 引擎。优点是语法灵活，支持很多扩展特性。缺点一个是慢(据说，我并没有太深刻的体会)，一个是&lt;em&gt;含中文的列表经常会解析出错&lt;/em&gt;，比如&lt;a href="/ACG/2012/03/03/sora-no-kiseki-ova2"&gt;这篇空轨OVA2的感想&lt;/a&gt;，如果使用 markdown 的标准语法写，被 maruku 解析后开头的12345就会乱掉，变成12125之类的东西……&lt;/li&gt;
&lt;li&gt;rdiscount 是 C 实现的 markdown 引擎，优点不用说也知道就是快。缺点就是完全以实现标准 markdown 句法为目标，完全不支持扩充句法。&lt;/li&gt;
&lt;li&gt;kramdown 是我目前在用的 markdown 引擎，速度按照其首页的说法是 maruku 的4倍。支持一些扩充句法，我认为足够了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装不同的引擎很容易，&lt;code&gt;gem install &amp;lt;引擎名&amp;gt;&lt;/code&gt;，然后对照着编辑&lt;code&gt;_config.yml&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3&gt;语法高亮&lt;/h3&gt;
&lt;p&gt;就说一句，需要安装 pygment，并找一个高亮用的 css 文件。
我是从阳志平先生的站点上 fork 过来的。&lt;/p&gt;
&lt;h2&gt;其他功能&lt;/h2&gt;
&lt;p&gt;kramdown 支持的 markdown 语法可以在其网站上&lt;a href="http://kramdown.rubyforge.org/syntax.html"&gt;找到&lt;/a&gt;，
虽然我没在里头看到&lt;code&gt;{: toc}&lt;/code&gt;这种用法——这就是本文开头的目录生成的方法。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/tagged/jekyll"&gt;stackoverflow&lt;/a&gt;
自然也是个去提高经验值的好去处。&lt;/p&gt;
&lt;p&gt;最近评论在 disqus 网站上有提供代码，Google Plus 按钮亦同。&lt;/p&gt;
&lt;p&gt;主页的分页可以查 jekyll 的 paginate 支持。
主页和侧栏的编排一看源码便知，也没有花太多精力，因此不再赘述。&lt;/p&gt;
&lt;h3&gt;友情链接&lt;/h3&gt;
&lt;p&gt;一开始不清楚 yaml 的表示方法，
然后忘记了 jekyll 只是一个模板语言，因此&lt;em&gt;就算看起来再怎么像 ruby，也没有 ruby 的完整功能&lt;/em&gt;。
因此用 ruby 的语法各种试各种报错，最初版本里循环也写的超难看。
后来用 yaml 在 page 的开头表示成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;links&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;url&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;https://plus.google.com/117704226616638577311&amp;quot;&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;Google&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;Plus&amp;quot;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;url&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://icemaple.info&amp;quot;&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;远凌风&amp;quot;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;url&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://ori0n.co.de&amp;quot;&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;暗夜北辰&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以遍历生成了。&lt;/p&gt;
&lt;h3&gt;github 仓库&lt;/h3&gt;
&lt;p&gt;显示 github 仓库状态的 javascript 文件 fork 自&lt;a href="https://github.com/dementrock/dementrock.github.com/blob/master/javascripts/github.js"&gt;这里&lt;/a&gt;。
稍作修改，改为使用v3的API.&lt;/p&gt;
&lt;h3&gt;加密&lt;/h3&gt;
&lt;p&gt;注意 jekyll 是一个&lt;em&gt;静态站点生成器&lt;/em&gt;，因此至少也会把密文暴露出来。
这一点上的确很遗憾。
如果不是发布在 github 上，自己写后端代码会更安全些。&lt;/p&gt;
&lt;p&gt;现在的实现方式是 post 前手动执行 rake，将文章用 ruby 加密。
然后在网页端用 javascript 解密。&lt;/p&gt;
&lt;p&gt;解密使用了&lt;a href="https://github.com/mdp/gibberish-aes"&gt;Gibberish-AES&lt;/a&gt;
这个 javascript 写的 AES 库。
为什么选择了这个库？
&lt;a href="http://stackoverflow.com/questions/8080525/js-ruby-aes-256-symmetry"&gt;因为&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In the end I used Gibberish AES which has both a Ruby and JavaScript implementation written by the same author&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原先实现它自己写了一个 jekyll 的 filter 插件，它在本地工作的很好，但是扔到 github 上的时候就发生了杯具——
github 不支持自定义插件(安全原因)。
所以最终实现为了一个 rake 的 task.
原理很简单，就是把原先使用插件渲染的过程手动执行一遍。
之前看过 ruby 的书，但是基本没有实战过(没需求的缘故，平时都用 python)。
这次也算是有点小收获。&lt;/p&gt;
&lt;p&gt;关于这类问题的解决方案，
网上还有说不 push 原始仓库而去 push 本地生成的站点的。
只能说这种方法不符合我的哲学，不然我就去选择用 &lt;a href="https://github.com/imathis/octopress"&gt;octopress&lt;/a&gt; 了。&lt;/p&gt;
&lt;p&gt;最后顺便吐槽一句，也许是我还不熟悉的缘故，但我目前感觉
irb 和 ipython 真的不在一个档次上……&lt;/p&gt;
&lt;h3&gt;slide&lt;/h3&gt;
&lt;p&gt;上学期英语口语课以及高级逻辑学课上用基于 python 的 &lt;a href="https://github.com/adamzap/landslide"&gt;landslide&lt;/a&gt; 做了两个 slide.
基于 html5 的效果确实不错——老实说，除了要自己带一个浏览器外真的很理想——学校里那堆反人类的 IE6 大家都懂的，还不如自己随手用 pyqt 写的一个临时 webkit 浏览器靠谱。&lt;/p&gt;
&lt;p&gt;给 blog 添加 slide 功能的动机之一是看到了&lt;a href="http://bmcmurray.github.com/hekyll/"&gt;这个项目&lt;/a&gt;。
出于好玩，本想直接拿来用。
不过实际操作时才发现这个项目写 slide 要分成好几个文件，让我觉得很疼，所以最后思量了一下，打算根据 landslide 来自己做一个。&lt;/p&gt;
&lt;p&gt;当时用 landslide 的时候并没怎么在意它是怎么工作的，基本上拿来用就是(虽然为了处理一些公式也手动写了个 python 程序来预处理，其中还包括一个方便写 div 的 markdown 扩充预处理)。
这次其实也没有仔细研究。
它的核心其实在 javascript 部分。
用于生成页面的 base.html 其实也是个模板文件，格式和 liquid 很像，所以移植从思路上没大有难度。&lt;/p&gt;
&lt;p&gt;结果最纠结的地方还是在 liquid 的表现力上，反复的用 capture ……
可能是因为之前用过的 web 框架是 Karrigell 和 bottle，
感觉写法被受限的这么严重的感觉好微妙(Karrigell 支持的模板方式略多……)，
有点让我想起以前用 ONS 写 Fate 的时候……&lt;/p&gt;
&lt;p&gt;其间也发现了 &lt;code&gt;split&lt;/code&gt; filter 只在本地有效，在 github 上无效的现象。
最终靠 javascript 在载入时重新编排页面内容，完成了 Table of Contents 和页码显示部分。
这么想来，其实我一开始在生成端就干脆不对页面处理，全交给 javascript 来做也可以啊……突然感到 bgm38 了……&lt;/p&gt;
&lt;p&gt;当然顺便加了 MathJax 支持，在页面的 head 里加几句就可以，和当时给 landslide 加的方法差不多，MathJax 还是很好用的。&lt;/p&gt;
&lt;h3&gt;有关 git&lt;/h3&gt;
&lt;p&gt;想学习一个东西，就应该&lt;a href="http://www.yangzhiping.com/tech/learn-program-psychology.html"&gt;进入学习区学习它&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;前两天系里发来通知，说是可以申请系里的主页空间。因此当时就想可以用同一份仓库来做这个事情。&lt;/p&gt;
&lt;p&gt;原来的分支只有 master(除了加 feature 的时候会分出临时分支)，
在此之上新建了一个 is 分支，用来放系里的主页；
新建了一个 dev 分支，用来保存这个 blog 和系里的主页共同的部分。&lt;/p&gt;
&lt;p&gt;dev 分支是从原 master 分支分叉后删掉多余部分改出来的。
原 master 分支被我直接备份出去，然后从 dev 分支重新分出来新 master 分支，
然后再将备份重新复制回来提交……
虽然很不科学，但在这个场合应该是合适的。因为之前没有考虑过分支问题，和 dev 有关的提交与只与 master 有关的提交的历史混在一起，分离太繁琐。&lt;/p&gt;
&lt;p&gt;is 分支很容易，直接从 dev 分支分出来即可。&lt;/p&gt;
&lt;p&gt;将来 dev 分支进展的话，master 分支可以 merge dev 分支，is 那边要上传 &lt;code&gt;_site&lt;/code&gt; 生成目录，直接 rebase 就可以了。&lt;/p&gt;
&lt;p&gt;merge 和 rebase 的最大区别在于，前者是&lt;strong&gt;在不改变过去的前提下从两个分支创造共同的未来&lt;/strong&gt;, 而后者是&lt;strong&gt;改变过去后重新来过以改变现在&lt;/strong&gt;。
因为 rebase 会改变历史，因此不应该在公开仓库上使用(嘛，虽然不会有人 clone 并提交这个页面吧，所以其实也可以 rebase，只是每次要加 force 参数不舒服……);
但也因为 rebase 不会产生新分支，因此适合给其他人的项目提交补丁或新特性，提交后维护者只需要直接采纳前进就可以，就不必合并并留下分支记录了。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;使用 Jekyll 搭建博客拥有非常多的优点，
譬如版本控制、markdown、轻量、静态、可定制、geek。
只要安心看说明，使用门槛其实并不太高。
我觉得是一种很适合喜欢生活里充满乐趣和安逸的人的选择。&lt;/p&gt;
</summary><category term="ruby"></category><category term="git"></category><category term="programming"></category></entry><entry><title>上帝看来很缺程序员……</title><link href="http://blog.skydark.info/programming/2011/10/25/rip-mcc/" rel="alternate"></link><published>2011-10-25T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2011-10-25:programming/2011/10/25/rip-mcc/</id><summary type="html">&lt;p&gt;RT, John McCarthy也去了，RIP……&lt;/p&gt;
</summary><category term="programming"></category><category term="AI"></category></entry><entry><title>RIP, R</title><link href="http://blog.skydark.info/programming/2011/10/13/rip,-r/" rel="alternate"></link><published>2011-10-13T00:00:00+08:00</published><author><name>Skydark Chen</name></author><id>tag:blog.skydark.info,2011-10-13:programming/2011/10/13/rip,-r/</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bye, Ritchie!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</summary><category term="programming"></category></entry></feed>